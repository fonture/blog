<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/tomee/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/tomee/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/tomee/blog/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/tomee/blog/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="欧阳德才">
<meta property="og:url" content="http://ouyangdecai.com/index.html">
<meta property="og:site_name" content="欧阳德才">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳德才">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/tomee/blog/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ouyangdecai.com/">





  <title> 欧阳德才 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/tomee/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">欧阳德才</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">day day no bug</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/tomee/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/tomee/blog/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/tomee/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tomee/blog/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2019/10/27/《解忧杂货店》读后感/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2019/10/27/《解忧杂货店》读后感/" itemprop="url">
                  《解忧杂货店》读后感
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-10-27T10:37:08+08:00">
                2019-10-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/书评/" itemprop="url" rel="index">
                    <span itemprop="name">书评</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2019/10/27/《解忧杂货店》读后感/" class="leancloud_visitors" data-flag-title="《解忧杂货店》读后感">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;第一次读东野圭吾的作品，以前只是有所耳闻，其作品以悬疑推理著称。就《解忧杂货店》而言，个人觉得不属于悬疑推理类作品，略带悬疑色彩，是为了在每个故事情节中埋下伏笔，引领读者读下去。不得不说这种手法很高明，让读者欲罢不能。先来梳理一下每个故事的主线吧。</p>
<h3 id="一、回答在牛奶箱里"><a href="#一、回答在牛奶箱里" class="headerlink" title="一、回答在牛奶箱里"></a>一、回答在牛奶箱里</h3><p>&emsp;&emsp;三个“小偷”翔太、敦也、幸平，因为偷来的汽车坏了，误入浪矢杂货店，其实说误入不对，因为敦也知道这个藏身地方是因为他前几天跟踪的他们要偷的那家的主人的行踪而知道这个地方的，此处不赘述，后文自有呼应。当他们找吃的的时候，突然从卷帘门掉一封信到瓦楞纸箱里，由此开启了他们三个与来自三十三年前的“月兔”的通信，“月兔”是一个运动员，但她的爱人罹患癌症，将不久于人世。她到底是应该放弃准备奥运会的训练陪伴爱人最后的时光，还是应该按照爱人的嘱咐坚持训练？她苦于在二者之中做出选择，因为她能参加奥运会是她爱人最大的心愿。翔太他们三人一直疑惑这到底是怎么回事，不过对于来信，他们第一次体会到被人需要的成就感。他们当然不能说出他们所知道的真相，只是建议她放弃比赛，全身心陪伴爱人。但最后事情的真相是，“月兔”自己的训练遇到了瓶颈，而此时她的爱人患了癌症，她正好有机会逃避训练，她的爱人早已看出她的心思，所以才要求她继续训练，不要她陪伴。本来翔太三人是出于他们知道她参加不了莫斯科奥运会而坚定地要她放弃训练去陪伴爱人，而被“月兔”阴差阳错地认为是浪矢先生对她是否真心向往奥运会的考验，由此让她做出了人生中正确的选择。故事的最后，三人又收到一个茶色的信封……</p>
<h3 id="二、深夜的口琴声"><a href="#二、深夜的口琴声" class="headerlink" title="二、深夜的口琴声"></a>二、深夜的口琴声</h3><p>&emsp;&emsp;松冈克郎祖传经营了一家鱼店，父亲一直坚持要克郎毕业后继承家业接手鱼店，可是克郎有着自己的坚持，他立志要成为一名歌手，还因此和父亲闹僵了。直到奶奶去世，他回家奔丧，发现父亲已经病倒，叔叔又在找父亲争家业，回想自己三年来音乐方面也没什么成就，因此很是心烦。在他将一个茶色的信封塞进了浪矢杂货店的卷帘门的前一夜，他出去散心时走到杂货店附近，看到了第一个故事中前来回最后一封感谢信的“月兔”，这里就把两个故事连接起来了。所以翔太他们收到的茶色信封就是克郎的，后面的通信也是克郎与他们三人的。不用说，克郎的烦恼就是他该如何选择，是回家继承鱼店？还是继续坚持自己的音乐梦想？回信言辞犀利，毫不留情地细数克郎的音乐路是如何的失败，继承家业是何等的优势，以至于克郎心生恼火，直到他父亲病倒住院，他决定放弃音乐接手鱼店！而此时，父亲松冈健夫却看出了儿子的心思：“你三年前决心要走音乐的路，当你一门心思投入的情况下，都无法走好一条路，你就别以为你干得好鱼店！并且以后干不好的时候，会说自己是因为放弃了音乐，牺牲了梦想才回来干鱼店的，少不了为自己开脱的理由。”我为什么要特别把这段叙述出来？因为我相信很多读者都有此共鸣，会因为一些事放弃自己的东西，而后心怨念，觉得自己多么的伟大，做出了多大的牺牲！但无论你做哪种选择，那都是你应该做的，人生没有回头路，走的每一步都算数！克郎因此深受启发，终在音乐路上小有成就。后来在丸光园的公益演出中，他以原创曲目《重生》，救赎了孤独少女小芹的内心，她是后续故事的主人翁之一。而后，克郎在丸光园的火灾中为求小芹的弟弟而去世……</p>
<h3 id="三、在思域车上等到天亮"><a href="#三、在思域车上等到天亮" class="headerlink" title="三、在思域车上等到天亮"></a>三、在思域车上等到天亮</h3><p>&emsp;&emsp;这一部分讲述了解忧杂货店的起源，一开始只是浪矢雄治为了逗小朋友开心，为小朋友回答一些奇奇怪怪的问题，比如说：如何能让自己考100分？雄治会把一些有趣的问题贴出来，但原则是不会透露任何关于对方的隐私！雄治在回答关于一个女人的问题，从后文知道她叫川边绿，这个女人怀了一个有妇之夫的孩子，是生下还是打掉？如果打掉她将再也不能有孩子了。贵之知道了真相后和父亲雄治统一建议她生下孩子！还没有等到女子的回信，雄治病倒了，在他最后的时间里，他要贵之带他回杂货店，回去后就收到了来自未来的回信。其中包括那个问如何让自己考100分的人写来的感谢信，他如今已经成为一名教师，并且将杂货店解答问题的经验应用到自己的岗位，能够引领学生更好地了解彼此。还有之前咨询是否要将孩子生下的那个女人的女儿的来信，信中提到，她以为自己是一个不被祝福的生命来到世上，尝试过自杀，幸好被救了下来，后来朋友劝解才知道，并不是母亲要带着她一起死，而是因为母亲生活已经很窘迫，把好的都留给了孩子，而自己因为贫血晕倒而导致了那次事故。帮她走出阴影的朋友就是第二个故事中的小芹，而川边绿的女儿成为了小芹的经纪人！雄治还收到了一封空白来信，从后文知道，这其实是敦也他们三个在复活夜写给杂货店的“咨询信”做试验，此处没有交代雄治是如何回信的，小说结尾会用这封回信呼应主题。故事最后，二0一二年九月，浪矢贵之嘱托浪矢骏吾“明年九月十三日”发布凌晨到黎明浪矢杂货店将会复活的消息。由此可以推论，浪矢雄治去世的时间是一九八零年九月十三日，而贵之回忆和父亲一年前的最后一次回信的场景，就是说收到川边绿的女儿的回信和那个提考100分问题的人的回信都是在一九七九年。贵之是在雄治去世后一个月在杂货店遇到的“月兔”，“月兔”说她的咨询是在“去年十一月。”，也就是说“月兔”的咨询就是在一九七九年的十一月份，那时候雄治已经搬到东京贵之的家里住了，杂货店没人，“月兔”的回信是三十四年后的翔太、敦也、幸平三人给回的！</p>
<h3 id="四、听着披头士默祷"><a href="#四、听着披头士默祷" class="headerlink" title="四、听着披头士默祷"></a>四、听着披头士默祷</h3><p>&emsp;&emsp;和久浩介出生在一个富庶的家庭，作为坡头士的忠实歌迷，他拥有一流的音乐设备，并且拥有了意外去世的表哥的所有披头士的唱片。后来，父亲的生意出了问题面临破产，高额欠款还不上，他们必须要举家逃亡。在逃走前，他把所有的唱片卖给了一个姓“前田”的朋友，他觉得父母面对问题逃跑是不对的，于是成为了浪矢杂货店第一个认真咨询烦恼的人。雄治给他的回信的意思是，父母逃跑固然不对，但他们可能经过考量，也许只是暂时缓和，等时机成熟再来面对，又或许他们有别的计划。但无论如何你都应该跟父母在一起，一起面对困难和问题而不能逃避！因为逃跑，浩介失去了对父母的信任，再加上披头士的解散，他觉得人与人之间被珍视的东西崩塌了，在逃跑的路上，浩介选择不听众杂货店的建议，抛弃了父母。随后他隐姓埋名改名“藤川博”，被送到孤儿院，也就是前文多次提到的丸光园。他在那里找到了兴趣——木雕。在八年后的丸光园火灾中，他遇到了曾经送过小狗木雕一起在丸光园长大的武藤晴美，武藤晴美是后续故事的主人翁，她后面还开了个小狗公司，生意风生水起，下文再叙。文中提到，浩介重游杂货店时遇到了50多岁的贵之，贵之说：“家父已经在8年前去世了。”由此推断丸光园火灾是在一九八八年。浩介在写给杂货店的感谢信中说他是大概四十年前给浪矢杂货店写的咨询信，也就是说浩介家的事发生在一九七三年前后。浩介从妈妈桑口中得知父母当年为了隐藏他独自逃走的消息，相约自杀从而可以保全他。他一直沾沾自喜没有听从浪矢爷爷的建议是万幸，可他从不知道这么多年的顺遂都是父母用死为他搭好的！但在最后浩介写给杂货店的感谢信中，他隐瞒了自己没有听从杂货店的建议并说自己一家人过得很幸福，他这样做也是不想让浪矢爷爷因为没有拯救一个家庭而内疚，也算是体现出了人性温暖的一面吧。</p>
<h3 id="五、来自天上的祈祷"><a href="#五、来自天上的祈祷" class="headerlink" title="五、来自天上的祈祷"></a>五、来自天上的祈祷</h3><p>&emsp;&emsp;这一部分先交代了翔太、敦也、幸平给第二个故事中的克郎的回信经过。然后是和“迷途的小狗”之间的通信，迷途的小狗其实就是上一部分提到的武藤晴美！笔名取为“迷途的小狗”也是因为浩介送她那个小狗木雕给她带来了温暖！晴美的烦恼是，她做陪酒小姐已经有丰厚的收入了，是否还有必要维持在公司那份打杂的工作？但三人在乎的点与晴美并不一样，他们认为做陪酒小姐就不是什么正经工作，晴美只是贪图奢侈，但晴美坚持的原则是陪酒只挣正当钱。双方为此产生激烈的争论，并因此交代了敦也为什么不同意晴美做陪酒小姐，因为他妈妈就是陪酒小姐，身边换了各种男人，他从来没受到过好的照顾，以至于后面也只能偷东西吃，最后，他被送到了丸光园。随后又交代了晴美的身世，晴美五岁的时候父母双亡，后来受到姨婆田村秀代一家的收留照顾，在上小学的时候被送到了孤儿院——丸光园。田村家斜对面有家姓北泽的，北泽静子比晴美大三岁，就是第一个故事中的“月兔”。上一个故事中晴美跟浩介有提到说自己因为得到朋友家附近一家杂货店的建议才开了小狗公司的，这个朋友就是静子——击剑运动员。晴美得知丸光园火灾后前去慰问，和院长皆月谈起了丸光园的历史，原来丸光园的创始人叫晓子，是现任皆月院长的亲姐姐，她上学的时候，与一名大她十岁的机械工谈恋爱。晓子家境殷实，父母当然不可能允许她和一名机械工在一起，他俩决定私奔，以她父亲的实力，他们的私奔当然以失败而告终！后来机械工托皆月带信给姐姐，信中无丝毫的怨恨，以博爱之心祝福晓子幸福以及对晓子父母的歉意。这个机械工，就是浪矢雄治！二零零三年，皆月院长去世，其长子苅谷接手丸光园，因为他经营不善，丸光园面临危机，但他为了骗取政府补助金，故意不接受外界帮助。晴美得知丸光园经营危机后，打算以个人名义出资接手重建丸光园，但苅谷为了达到他的目的，恶意散播谣言，说晴美要将丸光园改成情人酒店。对丸光园有深深情意的翔太、敦也、幸平三人，怎么可能坐视不管，他们听信谣言后，伺机要“干一票”，“抢”了晴美的钱财去救济丸光园！他们三个本来文化程度就不高，书读得少心却善，出此下策也是无奈之举。在“抢”了晴美的车后，他们发现了副驾上放着晴美写给浪矢杂货店九月十三日复活夜的感谢信，从这封信里得知了他们三个回信的那个“迷途的小狗”就是他们抢的这个武藤晴美！所以，第一个故事中他们抢的车是晴美的，而他们闯入杂货店的时间刚好是九月十三日夜里，即杂货店的复活夜！他们迎接黎明到来准备离开的时候，他们收到了浪矢爷爷给那一封空白信的回信：空白表示可以随心所欲地描绘，一切都是自由的，一切全在你自己，所以要相信自己，无悔地燃烧自己的人生！</p>
<p>&emsp;&emsp;五个小故事的梗概到此结束！可以看出作者利用倒叙和穿插的手法，将看似独立的小故事像穿珍珠一样慢慢串连起来。文中有几个值得提出的点：</p>
<ol>
<li>每一个故事的主人翁在走近解忧杂货店的时候，都有一段对杂货店周围的路和招牌的描写，烘托了故事发生地扣人心弦的氛围，突出杂货店作为整部小说主线的特殊地位。</li>
<li>读者应该意识到，晴美的成功，离不开敦也三人从未来的来信中的建议。但在现实生活中，没有穿越，没有谁可以预知未来，更不用想着能未卜先知从而找到人生的捷径，人生是没有捷径的，每一步都必须脚踏实地！文中只是一种采用悬疑的手法，所以希望读者可以理性看待这一点。</li>
<li>其实在大部分的咨询者中，他们的心里已经有了答案，只不过，他们的内心需要有个人推自己一把，找到一个说服自己的理由。浪矢爷爷就扮演了这样一个角色，这也是这部小说被称为治愈系小说的原因吧。</li>
<li>从第三部分可以看出浪矢爷爷在对待咨询者来信时候的态度，他明知道有些来信是恶作剧，但他依然坚持用最诚恳的态度来回答他们的来信，他很珍惜这份信任，同时也乐于帮助他人解决问题，这也是作者想表达的中心思想，一份信任，一份真心，便是生命的意义所在！</li>
</ol>
<p>&emsp;&emsp;追根溯源，晓子和浪矢雄治当年私奔未成，但他们彼此并无怨恨。晓子创办了孤儿院——丸光园，这个给翔太、敦也、幸平、小芹、克郎、浩介、晴美带来人生温暖和依靠的地方。雄治开了杂货店，后来也做着为别人排忧解难的事。两人此生无法结合，却将爱传递给别人，他们的爱交织在这些得到过帮助的人的生命中。我想，作者想要表达的是，无论是否在一起，只要心中有爱，这个世界就必定充满了爱！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2019/08/18/The-Moon-and-Sixpence/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2019/08/18/The-Moon-and-Sixpence/" itemprop="url">
                  关于《月亮和六便士》的思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T21:03:21+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/书评/" itemprop="url" rel="index">
                    <span itemprop="name">书评</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2019/08/18/The-Moon-and-Sixpence/" class="leancloud_visitors" data-flag-title="关于《月亮和六便士》的思考">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;查尔斯•斯特里克兰，一个生活在英格兰的中产阶级家庭，他是两个孩子的父亲和一个貌美且高雅的女人的丈夫，他是一名股交所经纪人，社会地位虽谈不上顶层上流但也还算富庶。</p>
<p>&emsp;&emsp;某一天，他突然离开了这个家，无声无息，毫无征兆！他抛充妻子，放弃在别人眼里看来极其幸福的生活，只身一人来到巴黎，追寻他所谓的梦想。在“我”见到他之前，他的妻子艾美和姐夫安德鲁上校一度猜测他带着某个女人私奔去享受奢靡浮华的生活去了，后来“我”见到他的时候，他过着食不果腹，靠人接济的生活，在“我”到巴黎之前，斯特里克兰太太拜托我一定要带他回去，她可以原谅他的一切过错，只要他回去。但“我”最终没能说动一个把关的思想者。</p>
<p>&emsp;&emsp;五年后，“我”在巴黎又见到斯特里克兰，此时的他已经是一个破烂邋遢，不修边幅的糟老头，创作上也还是默默无闻。后来他生了一场大病差点死掉，幸亏好心人斯特罗夫央求斯特罗夫太太（布兰琪）答应把他接到自己家悉心照顾，他痊愈之时却夺走了斯特罗夫太太，但两个月后斯特罗夫太太为他而自尽，他表现得一如既往的冷静，尤如他当离开英国那个家一样冷漠。一个星期后，斯特里克兰去了马赛。</p>
<p>&emsp;&emsp;斯特里克兰在马赛过了四个多月凄惨的流浪生活，睡地板，当水手，做工人，只要能填饱肚子，有时间画画，他什么都干。幸运的是，他遇到了尼科尔斯船长，把他带到了他最终的归宿——塔希提岛。</p>
<p>&emsp;&emsp;在塔希提，似乎一切都是他理想的生活，在这里，没有人笑话他的绘画水平有多差，这里的人总是那么宽容，这里允许一切的可能性，你哪怕是一个执著的疯子。约翰逊太太（缇亚蕾）常常接济他，给他买画笔、颜料。经她撮合，斯特里克兰和爱塔结婚，他们育有一儿一女，并且搬到了爱塔父母留下的山林里去生活。这里有山有水，自给自足，三年时间过去了。。。</p>
<p>&emsp;&emsp;据库特拉医生所说，斯特里克兰得了麻风病。当斯特里克兰得知这件事时，没有什么使他沮丧，他只关心他还有多少日子，他沉浸在艺术的创作中。在接下来的两三年中，斯特里克兰从虚弱到失明到最后死去，在他尸体的房子里，库特拉医生在墙壁上发现了真正艺术的画作。但斯特里克兰留下遗言叫爱塔将其付之一炬随他而去。给后人留下的只有叹挽。</p>
<p>&emsp;&emsp;以上就是一个“艺术家”，甚至可以说是一个疯子的故事。斯特里克兰从不在乎别人怎么说他，哪怕别人笑话他的画作，他甚至不在乎他的画值多少钱，他更不会拿自己的画换钱。但哪怕好心帮他的约翰逊太太都还后悔当初没有花二十法郎买下他那些没人看得入眼的画作，否则如今已经价值连城可以发一笔不小的财了。还有他惨死以后，斯特里克兰太太还在利用他把自己包装成一个贤内助。在之前的美好生活中，斯特里克兰太太说他是个“庸俗的小市民”，她根本不把他看在眼里。我想，斯特里克兰突然离家出走去寻找人生的价值，与他太太的态度不无关系。他太太总想结识社会名流，将自己标榜成一个受过艺术熏陶的上层人士。</p>
<p>&emsp;&emsp;也许我真的没有成为艺术家的潜智，因为我无论如何都理解不了布兰琪为他自尽后他为何还能表现得那么冷漠，而且斯特罗夫不遗余力地帮助他，他却夺走了他妻子，他心里竟然连一丝的愧疚都没有！我并不认为毛姆在创作这部小说的时候是为了讴歌什么。一个人，无论他在艺术方面造诣多高，他都不能以任何名义去伤害任何人！斯特里克兰是个失职的父亲，也是一个不负责任的丈夫。他更没有理由把布兰琪的死当作若无其事，更何况她曾是一个把他从死亡边缘救回来的大恩人的妻子，他应该受到良心的谴责！</p>
<p>&emsp;&emsp;在读完小说后，我好奇为什么小说的结尾没有点题。《月亮和六便士》这个名字与小说到底是怎么联系起来的。后来查资料，月亮象征崇高的理想追求和美妙的精神境界，也象征着离开伦敦的斯特里克兰甘之如饴的清贫；六便士这种小面额的硬币代表着世俗的鸡虫得失与蝇头小利，也代表着卡迈克尔所引以为豪的豪奢。月亮和六便士之间应该如何取舍，毛姆并没给出答案。但我认为，斯特里克兰是一个人格分裂的存在，人不应该为了追求“月亮”而将“六便士”视为鄙夷。所以，“月亮”只是一个目标，“六便士”也并不世俗，而是我们每天面对的现实并亟待解决的问题，无需非此即彼。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2018/09/22/es5方式实现promise/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2018/09/22/es5方式实现promise/" itemprop="url">
                  es5方式实现promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-22T17:32:20+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2018/09/22/es5方式实现promise/" class="leancloud_visitors" data-flag-title="es5方式实现promise">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于如何使用es5来实现es6中<code>promise</code>功能，重点在于创建<code>promise</code>的时候，它的回调函数是立即执行的，而其内部的<code>resolve</code>和<code>reject</code>方法又是通过<code>then</code>方法传进来的。那么，如何保证运行到调用成功或失败的操作时，其对应的回调函数是已经定义好了的呢？</p>
<p>&emsp;&emsp;创建promise对象时传进去的回调函数是立即执行的。为了保证在执行到成功或者失败的时候，其对应的回调函数已经定义了，我们可以借助<code>javascript</code>消息队列的特性来达到我们的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">this</span>.value = val</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		self.resolvedFun(self.value)</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">this</span>.value = val</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		self.rejectedFun(self.value)</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = resolvedFun</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = rejectedFun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法如下</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'begin to execute!'</span>);</span><br><span class="line">  <span class="keyword">var</span> number=<span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">if</span>(number&lt;=<span class="number">0.5</span>)&#123;</span><br><span class="line">    resolve(<span class="string">'less than 0.5'</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(<span class="string">'greater than 0.5'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(fn);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码：  </p>
<p>&emsp;&emsp;因为<code>MyPromise</code>的实例化和调用它的<code>then</code>方法，一前一后地被同步调用，在<code>MyPromise</code>内部的代码就要访问调用<code>then</code>方法时传进去的成功和失败的回调函数。如何才能让<code>then</code>方法中的回调函数“后来居上”呢？刚说了，<code>new MyPromise()</code>和<code>then</code>是一前一后的同步代码，也就是它们的执行是属于同一个事件循环的，我们只要把对失败或者成功的回调放到本次事件循环结束后再调用，就能保证在调用成功或者失败的操作时，它们的回调函数都是已经定义了的。所以我们在<code>resolve</code>和<code>reject</code>的实现中采用了<code>setTimeout</code>包装，在调用<code>then</code>方法的时候，将实例的<code>resolvedFun</code>和<code>rejectedFun</code>方法指向传进来的成功和失败的函数。<code>setTimeout</code>在本轮循环结束后才执行，所以，其内部要访问的<code>resolvedFun</code>和<code>rejectedFun</code>是早就被指定好的，这样，整个流程就已经完整了。</p>
<p>&emsp;&emsp;接下来就是给<code>MyPromise</code>加状态，我们知道es6中的<code>promise</code>一旦状态确定后就不会再被更改了。在上面的例子中成功和失败的结果都会被输出，这是不合理的。所以将<code>MyPromise</code>做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.status=<span class="string">'pending'</span></span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.resolvedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status == <span class="string">'reject'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.rejectedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = resolvedFun</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = rejectedFun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过后再调用，就只会输入一组结果了，要么成功，要么失败。<br>接下来就是要实现<code>MyPromise</code>的链式调用功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.status=<span class="string">'pending'</span></span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.resolvedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status == <span class="string">'reject'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.rejectedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve_next, reject_next</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">resolvedFunWrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> result = resolvedFun(self.value)</span><br><span class="line">			resolve_next(result)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">rejectedFunWrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> result = rejectedFun(self.value)</span><br><span class="line">			reject_next(result)</span><br><span class="line">		&#125;</span><br><span class="line">		self.resolvedFun = resolvedFunWrap</span><br><span class="line">		self.rejectedFun = rejectedFunWrap</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;之前的<code>then</code>方法很简单，只需要将成功和失败的回调函数赋给<code>MyPromise</code>实例的两个对应方法即可。但要实现链式调用的话，首先证明<code>then</code>方法返回的是一个<code>MyPromise</code>对象，其次就是本次成功或失败的结果要作为下一次成功或失败调用的函数的参数传进去。所以要对外层传进来的成功和失败的回调函数进行包装。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2018/08/15/前后端跨域解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2018/08/15/前后端跨域解决方案/" itemprop="url">
                  前后端跨域解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T21:28:56+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2018/08/15/前后端跨域解决方案/" class="leancloud_visitors" data-flag-title="前后端跨域解决方案">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p>为了避免前后端在联调的时候，遇到问题时前端都要在本机上修改然后再打包到服务器上调试。经过实践，现给出CORS（跨域资源共享）解决方案：</p>
<h4 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><blockquote>
<p>1.仅仅是跨域请求  </p>
</blockquote>
<ul>
<li>前端设置</li>
</ul>
<p>前端如果是用的es6框架，则需要在mock中补充如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	crossDomain: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端设置</li>
</ul>
<p>如果仅仅是为了解决跨域问题，后端则需要在每次请求时拦截，并在响应头中设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.既要跨域，又要携带cookie</p>
</blockquote>
<p>这种情况就不仅仅需要后端设置了，前后端必须同时设置  </p>
<ul>
<li>前端设置</li>
</ul>
<blockquote>
<p>ES6框架中采用的是<code>jquery</code>的<code>ajax</code>请求数据，需要在<code>mock</code>中做如下补充：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	crossDomain: <span class="literal">true</span>,</span><br><span class="line">	xhrFields: &#123;</span><br><span class="line">		withCredentials: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>react框架中采用的是axios请求，需要在mock中做如下补充：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	withCredentials: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端配置</li>
</ul>
<p>既要跨域，又要携带cookie，后端的<code>Access-Control-Allow-Origin</code>就不能显示设置为<em>了，它需要搭配另一个<code>Access-Control-Allow-Credentials</code>使用，并且其值为<code>true</code>。为了使<code>Access-Control-Allow-Origin</code>具有通用性并且不能为\</em> ，那么可以通过从request中动态获取当前的请求源来解决这个问题。所以，后端配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2018/04/15/React-Context-API解读/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2018/04/15/React-Context-API解读/" itemprop="url">
                  React Context API解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T10:45:26+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2018/04/15/React-Context-API解读/" class="leancloud_visitors" data-flag-title="React Context API解读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、为什么需要context-api"><a href="#一、为什么需要context-api" class="headerlink" title="一、为什么需要context api"></a>一、为什么需要context api</h3><p>–<br>在react开发过程中，我们可能会遇到这样的需求：某组件需要将值传给它的孙子，甚至嵌套更深的后代组件，如果不考虑context api，我们的实现方式，便是采用props逐层向下传递，直到需要获取到值的组件为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">	  <span class="keyword">return</span> &lt;Parent text='我是一个跨组件变量传递示例'/&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间层组件 parent.js</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">	constructor(props)&#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return &lt;Child text=&#123;this.props.text&#125;/&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要获取顶层组件的text值的底层组件 child.js</span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">	constructor(props)&#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return this.props.text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，应该肯定的是这种方式是可以实现的。但是一旦嵌套层数太多，在每一层组件里都要用<code>this.props</code>去接收上层组件传来的变量，那么，你的代码将陷入链式地狱，并且变得难以维护。由此，context api应运而生。</p>
<h3 id="二、旧版context-api"><a href="#二、旧版context-api" class="headerlink" title="二、旧版context api"></a>二、旧版context api</h3><p>–<br>关于context api是用来干什么的，在上一部分实际已经阐述出来了：解决跨组件数据传递的问题。在context api中，我们只需要在数据提供者（即顶层组件）中宣称：“本宝宝可以提供你们想要的xxx数据。”，然后在需要数据的组件中“回应”称：“本大大需要你的数据，请给我一份。”即可完成一次完整的跨组件数据传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	getChildContext()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			text: <span class="string">'我是旧版context api示例'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;Parent /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">GrandParent.childContextTypes = &#123;</span><br><span class="line">	text: PropTypes.string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间层组件 parent.js</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return &lt;Child /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要获取顶层组件的text值的底层组件 child.js</span><br><span class="line">import PropTypes from 'prop-types'</span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return this.context.text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child.contextTypes = &#123;</span><br><span class="line">	text: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较于props的传递方式，context api不用在每个中间层组件中都显示地将props中的text设置到子组件的属性中，对于跨组件的数据传递确实提供了方便。但这种方式的缺陷在于：由于中间层组件并不依赖于context的存在，如果中间层某个组件采用<code>shouldComponentUpdate</code>做组件优化，限制了组件更新的条件，而组件更新只与props、state有关，与context并无关系。所以，顶层组件更新，可能导致底层组件并不会更新。</p>
<h3 id="三、新版context-api"><a href="#三、新版context-api" class="headerlink" title="三、新版context api"></a>三、新版context api</h3><p>–<br>新版context api从形式上来看，更符合react风格：组件化的处理方式，用Provider来包裹顶层组件，用Consumer来包裹底层获取数据的组件，同样是宣称“本宝宝可以提供数据”，也同样是“本大大需要你的数据”，新版api不再像旧版本那样对组件产生额外的除生命周期以外的钩子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建供全局使用的context store.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> context = React.createContext()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = context.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = context.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  text: <span class="string">'新版context api示例'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;Provider value = &#123;store&#125;&gt;</span><br><span class="line">        &lt;MsgContainer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 中间层组件 parent.js</span></span><br><span class="line"><span class="regexp">class Parent extends Component&#123;</span></span><br><span class="line"><span class="regexp">	render()&#123;</span></span><br><span class="line"><span class="regexp">		return &lt;Child /</span>&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要获取顶层组件的text值的底层组件 child.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          context =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> context.text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上，新版的context api仍然存在缺陷。假如某个组件要获取的数据有多个数据来源，那么，其组件结构类似以下的形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt;</span><br><span class="line">	&lt;B&gt;</span><br><span class="line">		&lt;C&gt;</span><br><span class="line">			...</span><br><span class="line">		&lt;<span class="regexp">/C&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>B&gt;</span><br><span class="line">&lt;<span class="regexp">/A&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>是不是很熟悉的嵌套地狱！如果真的遇到这种需求，我们应该依赖于第三方框架类似redux、mobx等来实现。这些框架的底层实际上也是用context api来实现的。</p>
<h3 id="四、redux将被取代？"><a href="#四、redux将被取代？" class="headerlink" title="四、redux将被取代？"></a>四、redux将被取代？</h3><p>–<br>社区有人讨论说，随着context api的优化，会不会导致redux被丢弃？答案是：不会！因为无论是新版的context api还是旧版的context api，解决的都是跨层级组件间的数据传递的问题。原生的context api并不能强大到做系统级的数据管理。所以，context api只是让我们理解原理，真正的应用，正是这些强大的框架赋予我们的力量！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2017/11/04/selections/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2017/11/04/selections/" itemprop="url">
                  selections工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-04T21:23:10+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2017/11/04/selections/" class="leancloud_visitors" data-flag-title="selections工作原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">https://bost.ocks.org/mike/selection/</a></p>
<p>以前，我对D3的选择集有过一些简单的描述，其中的讲解仅限于入门。 这篇文章以更加全面的方式讲解如何使用选择集，我会说明选择集是如何执行的。这篇文章有点长，但它将消除你的诸多疑虑并助你掌握数据驱动文档（Data-Drive Documents）。</p>
<p>这篇文章的开头似乎让人觉得有点随意，它讲述的是selections的内部工作原理而并非设计的动机，因此你可能会疑问为什么要以这种方式呈现。很简单，在解释所有东西是如何工作之前，先把所有的东西放在一起比较容易。等你读到最后，设计意图和功能也逐渐清晰。</p>
<p>D3是一个可视化库，因此这篇文章会伴随讲解一些可视化方面的知识。在下面的示意图中，左边的图将会展示selections的结构，右边的图将会展示数据结构。<br><!-- ![selections join](selections/join.jpg) --></p>
<p>圆角矩形比如：<span style="background:rgb(217,217,217);padding:3px 5px;border-radius:5px;">thing</span>表示各种类型的JavaScript对象，包括对象字面量，数字组成的数组以及DOM元素。确定的对象类型用不同的颜色标识，包括<span style="border:1px solid rgb(227,86,33);padding:3px 5px;border-radius:5px;">selection</span>、<span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">array</span>以及<span style="background:rgb(185,185,185);padding:3px 5px;border-radius:5px;">element</span>。从一个对象到另一个对象的引用用关联线来表示（——）。比如，一个包含数字42的数组是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array = [42];</span><br></pre></td></tr></table></figure>
<p><span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">array</span>——<span style="background:rgb(217,217,217);padding:3px 5px;border-radius:5px;">42</span></p>
<p>只要有可能，生成给定选择集的代码就会立即出现在图的上方。打开浏览器的JavaScript控制台并以交互方式创建选择集是测试你对文本理解的好方法！</p>
<p>~正文从这里开始</p>
<h3 id="一、数组的子类"><a href="#一、数组的子类" class="headerlink" title="一、数组的子类"></a>一、数组的子类</h3><p>你可能会说，选择集不就是DOM元素组成的数组嘛！错！一方面，选择集是数组的一个子类，这个子类提供了操作被选中的selections的方法，比如说设置属性和样式。选择集同样继承数组的原生方法，比如说array.forEach及array.map。然而，你将很少用到数组的原生方法，因为D3提供了更加便利的替代方案，比如selection.each(为了适应selections的书写规范，少许几个原生方法被D3重写了，即selection.filter和selection.sort)。</p>
<h3 id="二、分组元素"><a href="#二、分组元素" class="headerlink" title="二、分组元素"></a>二、分组元素</h3><p>选择集不同于数组的另一个原因是，选择集是元素的数组的数组：一个选择集是一个包含众多分组的数组，并且每一个分组是一个包含众多元素的数组。比如’d3.select‘方法返回一个group的集合，而这个group包含的是被选中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selection = d3.select(&quot;body&quot;);</span><br></pre></td></tr></table></figure>
<p><span style="border:1px solid rgb(227,86,33);padding:3px 5px;border-radius:5px;">select</span> —— <span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">group</span> —— <span style="background:rgb(185,185,185);padding:3px 5px;border-radius:5px;">body</span></p>
<p>在javascript控制台，试着运行这段代码，并且查看一下分组selection[0]以及节点<code>selection[0][0]</code>。D3的API提供了直接访问节点的入口，最为常见的是使用selection.node。</p>
<p>同样的，d3.selectAll返回一个组和任何数量的元素的选择集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;h2&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/1.jpg) -->
<p>d3.select和d3.selectAll返回的选择集都有一个组，获取包含多个组的选择集的唯一方法是selection.selectAll。比如，如果你要选择一张表的所有的行元素，并且随后选择每一行的所有单元格，你会获取到一组包含多个单元格的group分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;tr&quot;).selectAll(&quot;td&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/2.gif) -->
<p>通过selectAll，旧的选择集中的每一个元素都会在新的选择集中变成一个分组；每个组包含一个旧元素及其匹配的后代元素。因此，如果每个单元格中包含一个’span’元素，并且你后续进行第三次selectAll调用，你将得到一个包含16个分组的选择集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;tr&quot;).selectAll(&quot;td&quot;).selectAll(&quot;span&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/3.gif) -->
<p>每个组都有一个parentNode属性，用于存储所有组元素的共享父元素。父元素在创建组的时候被设置，如果你调用d3.selectAll(“tr”).selectAll(“td”)，返回的选择集是包含td元素的分组，它们的父节点是tr元素。对于d3.select和d3.selectAll方法返回的结果集，它们的父元素是html。</p>
<p>更多时候，你可以忽略那些被分组的选择集。当你给attr或者style赋值为一个函数时，这个函数会被选择集中的每一个元素调用，分组和元素集最主要的区别在于函数的第二个参数i，i表示的是组内的索引而并非选择集内索引。</p>
<h3 id="三、非分组操作"><a href="#三、非分组操作" class="headerlink" title="三、非分组操作"></a>三、非分组操作</h3><p>只有selectAll可以产生分组行为，select保留现有分组。select方法不同，因为每个元素的选择中只有一个元素。因此，select会将数据从父节点传送到子节点，而selectAll不会！</p>
<p>append和insert方法是基于select之上的包装，所以它们也会保存分组及传送数据。比如：给一个document添加4个section元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/4.jpg) -->
<p>如果你给每个section元素添加一个p元素，新的选择集同样只有唯一一个分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;).append(&quot;p&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/5.jpg) -->
<p>注意：这个selectAll选择集的parentNode依然是html元素，因为selection.selectAll被调用并不会导致重新分组</p>
<h3 id="四、空元素"><a href="#四、空元素" class="headerlink" title="四、空元素"></a>四、空元素</h3><p>分组可以包含null以表示丢失的元素，null元素被众多操作所忽略；比如，D3在设置属性和样式的时候会跳过null元素。</p>
<p>当selection.select不能找到和给定选择器相匹配的元素时，就会产生null元素。select方法必须维持既有的分组结构，所以会用null来占位。比如，如果在上面的例子中只有最后两人个section元素中含有aside元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;).select(&quot;aside&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/6.jpg) -->
<p>和分组一样，你可以忽略null空元素。不过你要注意的是，null空元素依然维持着它的分组结构以及它的组内索引。</p>
<h3 id="五、数据绑定"><a href="#五、数据绑定" class="headerlink" title="五、数据绑定"></a>五、数据绑定</h3><p>令人意外的是，data并不是选择集的属性，而是其元素的属性。这意味着当你给选择集绑定数据集时，数据是被存储在DOM元素上的，而不是存储在选择集里（数据被存储在元素的一个叫做<code>__data__</code>的属性中）。如果一个元素没有这个属性，则其关联数据为undefined。因此数据是持久的而选择集可以被看作是暂时的（你可以重新选择DOM中的元素，并保留着之前绑定的数据）。</p>
<p>数据可以通过以下几种方式被绑定到元素上：</p>
<blockquote>
<p>1.通过selection.data将数据绑定到元素上；</p>
</blockquote>
<blockquote>
<p>2.通过selection.datum分配给各个元素；</p>
</blockquote>
<blockquote>
<p>3.通过append、insert或select从父元素继承数据绑定</p>
</blockquote>
<p>虽然没有必要直接设置<code>__data__</code>属性，可以使用selection.datum来绑定，但这样做可以说明如何实现数据绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.__data__ = 42;</span><br></pre></td></tr></table></figure>
<!-- ![](selections/7.jpg) -->
<p>相当于选择body元素并为它绑定数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.select(&quot;body&quot;).datum(42);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/8.jpg) -->
<p>如果我们现在在body元素下面再添加一个元素，那么其子元素会自动继承来自父元素的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.select(&quot;body&quot;).datum(42).append(&quot;h1&quot;);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/9.jpg) -->
<p>以上阐明了最后一种绑定数据的方法，在进一步的探索之前，我们必须回答更具现实意义的问题。</p>
<h3 id="六、什么是数据"><a href="#六、什么是数据" class="headerlink" title="六、什么是数据"></a>六、什么是数据</h3><p>D3中的数据可以是任何值的数组。比如，数值型数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [4, 5, 18, 23, 42];</span><br></pre></td></tr></table></figure>
<p>或者包含对象的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var letters = [</span><br><span class="line">  &#123;name: &quot;A&quot;, frequency: .08167&#125;,</span><br><span class="line">  &#123;name: &quot;B&quot;, frequency: .01492&#125;,</span><br><span class="line">  &#123;name: &quot;C&quot;, frequency: .02780&#125;,</span><br><span class="line">  &#123;name: &quot;D&quot;, frequency: .04253&#125;,</span><br><span class="line">  &#123;name: &quot;E&quot;, frequency: .12702&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>甚至包含数组的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matrix = [</span><br><span class="line">  [ 0,  1,  2,  3],</span><br><span class="line">  [ 4,  5,  6,  7],</span><br><span class="line">  [ 8,  9, 10, 11],</span><br><span class="line">  [12, 13, 14, 15]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们可以通过可视化呈现选择集与数据的映射关系，这里有一个5个数字的简单数组：<br><!-- ![](selections/10.jpg) --></p>
<p>就像selection.style使用一个常量字符串来为每一个选定的元素定义一个统一的样式属性，或者通过函数来返回每个元素的动态样式(<code>function(d) {return d.color; }</code>)，selection.data可以接受一个常量值或一个函数。</p>
<p>然而，与其他的选择集方法不同，selection.data为每个组定义数据而不是每个元素（数据被表示为与组对应的数组，或是返回类似数组的函数。因此，一个被分组的选择集具有相应的分组数据）<br><!-- ![](selections/11.jpg) --></p>
<p>图中的蓝线表明返回关联数组的函数，数据函数传递组的父元素的数据(d)及其组内索引(i)，并返回你想要加入组内的所有数据的数组。因此，数据通常表示的是绑定到父元素的数据函数，便于从分层数据创建分层DOM元素。</p>
<p>对于只有一个组的选择，可以直接将相应的单个数组传递给selection.data；你只有在将不同的数据绑定到不同分组的时候才需要函数操作</p>
<h3 id="七、关键知识点"><a href="#七、关键知识点" class="headerlink" title="七、关键知识点"></a>七、关键知识点</h3><p>要将数据和元素关联，我们必须知道哪个元素对应哪个数据，这归功于一组配对的键，一个键是一个标识字符串，比如说名称，当一个数据的键和元素的键相等时，这个数据就被分配给对应的这个元素。</p>
<p>索引是分配键最简单的方式（第一个数据和第一个元素有相同的键“0”，第二个数据和第二个元素有相同的键“1”，依次类推……）。将一组数据连接到匹配的paragraph元素数组，因此看起来像这样，键显示为绿色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [4, 5, 18, 23, 42];</span><br></pre></td></tr></table></figure>
<!-- ![](selections/12.jpg) -->
<p>现在，选择的结果集就是绑定到数据的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;div&quot;).data(numbers);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/13.jpg) -->
<p>如果你的数据和元素都是按照既定的顺序排列的，那么按照索引匹配无疑是最方便的。然而，当顺序不同的时候，按照索引匹配不再可取！在这个例子中，你可以指定一个键函数作为data方法的第二个参数传进去。键函数返回指定的数据或元素的键值，如果你的数据是包含对象的数据，而每个对象都有一个name属性，你的键函数就可以返回关联的name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var letters = [</span><br><span class="line">  &#123;name: &quot;A&quot;, frequency: .08167&#125;,</span><br><span class="line">  &#123;name: &quot;B&quot;, frequency: .01492&#125;,</span><br><span class="line">  &#123;name: &quot;C&quot;, frequency: .02780&#125;,</span><br><span class="line">  &#123;name: &quot;D&quot;, frequency: .04253&#125;,</span><br><span class="line">  &#123;name: &quot;E&quot;, frequency: .12702&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function name(d) &#123;</span><br><span class="line">  return d.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<!-- ![](selections/14.jpg) -->
<p>由此，所选元素现在绑定到数据。 这些元素也被重新排序以匹配数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;div&quot;).data(letters, name);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/15.jpg) -->
<p>对于大型分组选择，这个过程可能相当复杂。但由于每个分组独立关联，因此被简化。因此，你只需要担心组内的唯一键，而不是整个选择集。<br><!-- ![](selections/16.jpg) --></p>
<p>上面的例子假设数据和元素之间有一个精确的1：1匹配。 但是，如果给定的数据没有匹配的元素，或给定的元素没有匹配的数据，会发生什么？</p>
<h3 id="八、Enter、Update及Exit"><a href="#八、Enter、Update及Exit" class="headerlink" title="八、Enter、Update及Exit"></a>八、Enter、Update及Exit</h3><p>当按键将元素加入数据时，有三种可能的逻辑结果：</p>
<p>1、Update-对于给定的数据能找到匹配的元素</p>
<p>2、Enter-对于给定的数据不能找到匹配的元素</p>
<p>3、Exit-对于给定的元素找不到匹配的数据</p>
<p>以上就是由selection.update、selection.enter、selection.exit各自返回的三类结果集。想象一下，你有一个字母表的前五个字母的条形图(ABCDE)，你想过渡到你最喜欢的五个元音(YEAOI)，你可以使用键功能在转换中保持字母之间的关联，从而产生以下数据连接：<br><!-- ![](selections/17.jpg) --></p>
<p>之前显示的两个字母（A和E）是元音，这些条形按照新数据的顺序放置在更新选项中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = d3.selectAll(&quot;div&quot;).data(vowels, name);</span><br></pre></td></tr></table></figure>
<!-- ![](selections/18.gif) -->
<p>另外三个显示的字母（B，C和D）是辅音，因此在新数据集中没有相应的数据。 这些元素因此被放置在Exit选择集中。 请注意，Exit选择集会保留原始选择的顺序，在移除之前进行动画制作时，此选项有时很有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.exit();</span><br></pre></td></tr></table></figure>
<!-- ![](selections/19.gif) -->
<p>最后，三个元音（Y，O和I）以前没有显示，因此没有相应的元素。 这些形成了Enter选择集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.enter();</span><br></pre></td></tr></table></figure>
<!-- ![](selections/20.gif) -->
<p>Update和Exit是常用的选择集，Enter则是选择集的一个子集。这是必要的，因为它代表了还不存在的元素，Enter选择集包含了占位符而并非实际存在的DOM元素，这些占位符只是具有<code>__data__</code>属性的对象。当后续插入节点时，这些新节点会替换原有的占位符而成为Enter中的新成员。</p>
<h3 id="九、合并Enter和Update"><a href="#九、合并Enter和Update" class="headerlink" title="九、合并Enter和Update"></a>九、合并Enter和Update</h3><p>数据的一般更新模式是添加缺省的元素并移除多余的元素，同时修改更新元素的动态属性、样式以及其他属性。通常，更新和缺省元素的属性之间有重叠。</p>
<p>为了减少重复的代码，enter.append有一个方便的附加功能：它使用enter选择集中新创建的元素替换update选择集中的null。因此，在enter.append之后，update选择集被修改为包含enter和update元素。 随后update选择集就包含所有当前显示的元素：<br><!-- ![](selections/21.jpg) --></p>
<p>自此，数据关联的生命周期就完成了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2017/03/22/js-node-operation/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2017/03/22/js-node-operation/" itemprop="url">
                  js关于节点操作的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-22T08:43:01+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2017/03/22/js-node-operation/" class="leancloud_visitors" data-flag-title="js关于节点操作的问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刚看到原生js操作节点这部分，于是动手敲了几行代码练习一下节点操作方法的应用。真没想到还遇到了一个棘手的问题，下面进入正题：<br>首先，我在body里边简单写了个无序列表，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">style</span>=<span class="string">"list-style:none;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>JAVA<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我在js里边都干了些什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa_text=<span class="built_in">document</span>.createTextNode(<span class="string">'python'</span>);</span><br><span class="line">suanfa.appendChild(suanfa_text);</span><br><span class="line">ul.insertBefore(suanfa,ul.lastChild);</span><br><span class="line"><span class="keyword">var</span> nodes=ul.children;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第1句获取ul的DOM对象，第2句到第4句创建了一个新的li节点，并为它添加了文本“python”，然后把新节点插入在了ul的倒数第2个子节点上。最后，循环输出每个子节点信息。此时，机智的你是不是会认为，下面就是输出结果：<br><img src="/tomee/blog/2017/03/22/js-node-operation/1.png" alt="第1次测试输出结果"><br>然而，并不是！！！真正的输出结果是下面这个：<br><img src="/tomee/blog/2017/03/22/js-node-operation/2.png" alt="第2次测试输出结果"><br>纳尼？？？你是不是也在想，明明是在lastChild进行的insertBefore，为什么python还是排到最后一个去了？我之前也想不明白，直到我把var nodes=ul.children换成了childNodes，再打印出来，请看：<br><img src="/tomee/blog/2017/03/22/js-node-operation/2.png" alt="childNodes获取的结果集"><br>这一看结果，相信你也就明白了。尽管我们知道，节点的children属性不会获取文本节点，而childNodes会获取文本节点。但不曾想过，js的节点插入操作将非元素结点也算作子节点的！所以，我上面的insertBefore不过是在最后那个#text元素前面插入了一个li元素，显示的时候，它还是所有li元素当中的最后一个，因此出现了之前那个问题。</p>
<p>解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa_text=<span class="built_in">document</span>.createTextNode(<span class="string">'python'</span>);<span class="keyword">debugger</span>;</span><br><span class="line">suanfa.appendChild(suanfa_text);</span><br><span class="line">ul.insertBefore(suanfa,ul.children[ul.children.length<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">var</span> nodes=ul.children;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即，将insertBefore的第二个参数换成ul.children[ul.children.length-1]，实际上就是利用children属性只返回节点，不获取属性和文本的特性，以此获取最后一个子元素对象，再插件元素。其实，理解了以后就会发现，这种情况也就是在正数第2个位置和倒数第2个位置插入元素会产生异常（前提是除了li没有别的元素）。</p>
<p>最后，关于#text的一些思考：哪些情况下会产生#text文本节点？jQuery中的befor和after方法是怎样封装的？望各位大大多多指点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2017/03/18/build-react-babel-webpack-environment/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2017/03/18/build-react-babel-webpack-environment/" itemprop="url">
                  手动创建react+babel+webpack开发环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-18T12:46:22+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/环境搭建/" itemprop="url" rel="index">
                    <span itemprop="name">环境搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2017/03/18/build-react-babel-webpack-environment/" class="leancloud_visitors" data-flag-title="手动创建react+babel+webpack开发环境">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;从年前到现在一直在找工作，也由于家里的一些事情耽搁。所以，搁置已久的日志，是时候重新拾起记录了。由于之前在项目中尽量用的脚手架，甚至有些小项目根本就没有搭建什么框架。于是，今天琢磨了一下全手动搭建react+webpack+babel开发环境。一方面填坑，另一方面借此机会熟悉一下这些工具的API。以下正文：</p>
<h2 id="一、npm初始化"><a href="#一、npm初始化" class="headerlink" title="一、npm初始化"></a>一、npm初始化</h2><blockquote>
<p>npm init</p>
</blockquote>
<p>&emsp;&emsp;npm是时下相对流行的包管理器,使用此命令创建package.json文件，这个文件包含了项目中所有包的版本信息、依赖关系等。</p>
<h2 id="二、安装webpack"><a href="#二、安装webpack" class="headerlink" title="二、安装webpack"></a>二、安装webpack</h2><blockquote>
<p>npm install webpack -g</p>
</blockquote>
<p>&emsp;&emsp;安装完成后，在项目根目录创建一个webpack.config.js用于配置webpack。一定要全局安装。</p>
<h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><p>&emsp;&emsp;用于配置项目入口文件</p>
<h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><p>&emsp;&emsp;用于配置打包后文件的去向。其中，filename表示打包后的js叫什么名字，path表示打包后的文件所在的目录。如：<code>path=__dirname+&quot;/dist&quot;,filename=&quot;bundle.js&quot;</code>表示执行package打包后，在项目根目录下会新建一个dist文件夹，其中包含一个bundle.js文件，这个文件就是打包后的js。</p>
<h3 id="3-devServer"><a href="#3-devServer" class="headerlink" title="3.devServer"></a>3.devServer</h3><blockquote>
<p>npm install –save-dev webpack-dev-server</p>
</blockquote>
<p>&emsp;&emsp;用于配置webpack服务器。这部分配置比较关键，这是webpack提供的热更新功能，即时修改，即时出效果。其中比较主要的几个配置有：</p>
<blockquote>
<p><strong>conentBase</strong>。服务器启动后访问的根目录，比如：<code>contentBase:&quot;./dist&quot;</code>表示服务器开启后访问的是当前项目下的dist目录。<br><strong>inline</strong>。其值为布尔值，如果设置为true，表示开启热更新功能。否则不开启。<br><strong>port</strong>。用于设置服务端口，默认是8080。<br><strong>historyApiFallback</strong>。布尔值，这个属性设置在spa项目开发中非常有用，如果设置为true，所有的跳转将指向index.html</p>
</blockquote>
<p>注意：<br>&emsp;&emsp;1.webpack-dev-server指令用于启动webpack服务器，如果在后面加上<code>--content-base</code>表示服务器启动后访问devServer配置中contentBase指定的目录。如果为缺省值，表示访问当前项目的根目录。<br>&emsp;&emsp;2.“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
<h3 id="4-loaders配置"><a href="#4-loaders配置" class="headerlink" title="4.loaders配置"></a>4.loaders配置</h3><p>&emsp;&emsp;loaders配置写在module模块下。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。其中主要的配置属性有：</p>
<blockquote>
<p><strong>test</strong>。一个匹配loaders所处理的文件的拓展名的正则表达式（必须）。如：<code>test:&quot;/\.jsx$/&quot;</code>表示匹配所有的jsx语法，还有json、js、img、css、less、scss等文件格式匹配。<br><strong>loader</strong>。指定loader名称。如： <code>babel、json、babel-loader、css-loader、style-loader</code>等。<br><strong>include/exclude</strong>。手动指定包含/不包含的文件或文件夹。如：node_modules中的文件一般是不需要我们用loader进行转换的，可以手动排队这个文件夹下的所有文件。使用<code>exclude:/node_modules/</code><br><strong>query</strong>。一些额外的配置。</p>
</blockquote>
<h2 id="三、babel安装和配置"><a href="#三、babel安装和配置" class="headerlink" title="三、babel安装和配置"></a>三、babel安装和配置</h2><blockquote>
<p>npm install –save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</p>
</blockquote>
<p>&emsp;&emsp;<code>babel-core</code>是babel的核心库，babel-loader是jsx的loader,babel-preset-es2015是es6的转换器，babel-preset-react是react的语法转换器。<br>&emsp;&emsp;配置babel有两种方式：</p>
<h3 id="1-在webpack的loader里配置"><a href="#1-在webpack的loader里配置" class="headerlink" title="1.在webpack的loader里配置"></a>1.在webpack的loader里配置</h3><p>&emsp;&emsp;在loader里加上query:{presets:[‘es2015’,’react’]}</p>
<h3 id="2-配置-babelrc文件"><a href="#2-配置-babelrc文件" class="headerlink" title="2.配置.babelrc文件"></a>2.配置.babelrc文件</h3><p>&emsp;&emsp;新建.babelrc文件，按照如下配置即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;es2015&quot;,&quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、配置完成。开始工程"><a href="#四、配置完成。开始工程" class="headerlink" title="四、配置完成。开始工程"></a>四、配置完成。开始工程</h2><blockquote>
<p>npm install –save react react-dom</p>
</blockquote>
<h3 id="1-安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示："><a href="#1-安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示：" class="headerlink" title="1.安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示："></a>1.安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示：</h3><p><img src="/tomee/blog/2017/03/18/build-react-babel-webpack-environment/project.png" alt="项目目录"></p>
<h3 id="2-在src下新建main-js文件，其中的代码也很简单，就是用react在页面输出一个hello-world（这貌似是业界接触新技术的必写经典案例，哈哈。）"><a href="#2-在src下新建main-js文件，其中的代码也很简单，就是用react在页面输出一个hello-world（这貌似是业界接触新技术的必写经典案例，哈哈。）" class="headerlink" title="2.在src下新建main.js文件，其中的代码也很简单，就是用react在页面输出一个hello world（这貌似是业界接触新技术的必写经典案例，哈哈。）"></a>2.在src下新建main.js文件，其中的代码也很简单，就是用react在页面输出一个hello world（这貌似是业界接触新技术的必写经典案例，哈哈。）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from  &quot;react-dom&quot;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;hello,worlddddd&lt;/h1&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-在项目根目录新建index-html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是-dist-bundle-js，否则页面不能引用到main-js里的内容。"><a href="#3-在项目根目录新建index-html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是-dist-bundle-js，否则页面不能引用到main-js里的内容。" class="headerlink" title="3.在项目根目录新建index.html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是./dist/bundle.js，否则页面不能引用到main.js里的内容。"></a>3.在项目根目录新建index.html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是<code>./dist/bundle.js</code>，否则页面不能引用到main.js里的内容。</h3><h3 id="4-执行webpack进行打包"><a href="#4-执行webpack进行打包" class="headerlink" title="4.执行webpack进行打包"></a>4.执行webpack进行打包</h3><h3 id="5-执行webpack-dev-server-–content-base。可以看到hello-world正常显示出来了。此时个性main-js里的内容，页面上会实时更新。"><a href="#5-执行webpack-dev-server-–content-base。可以看到hello-world正常显示出来了。此时个性main-js里的内容，页面上会实时更新。" class="headerlink" title="5.执行webpack-dev-server –content-base。可以看到hello world正常显示出来了。此时个性main.js里的内容，页面上会实时更新。"></a>5.执行webpack-dev-server –content-base。可以看到hello world正常显示出来了。此时个性main.js里的内容，页面上会实时更新。</h3><h2 id="五、写在后面"><a href="#五、写在后面" class="headerlink" title="五、写在后面"></a>五、写在后面</h2><p>&emsp;&emsp;当我执行webpack后，发现在打包的dist目录下，并没有找到我的index.html文件，按道理来说，html文件不是应该随着打包一起进去的吗，否则我在发布的时候没有html怎么行。后来百度才发现，漏掉了最重要的一个东西：<code>HtmlWebpackPlugin</code>。这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。也就是说，有了这个配置，在html中根本不需要我们手动引入js文件，打包的时候html会根据配置自动引入。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><blockquote>
<p>npm install –save-dev html-webpack-plugin</p>
</blockquote>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>&emsp;&emsp;在webpack配置文件中顶部加入：<code>var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code>。在plugins里进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title:&quot;react demo&quot;,</span><br><span class="line">            filename:&quot;index.html&quot;,</span><br><span class="line">            template:&quot;index.html&quot;,</span><br><span class="line">            inject:true</span><br><span class="line">        &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>title</strong>:表示html中title的值<br><strong>filename</strong>:输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。<br><strong>template</strong>: 模板文件路径，支持加载器，比如 html!./index.html<br><strong>inject</strong>: true | ‘head’ | ‘body’ | false  ,注入所有的资源到特定的 template 或templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，’head’ 将放置到 head 元素中。</p>
</blockquote>
<h3 id="3-去掉html中的script引用，执行webpack"><a href="#3-去掉html中的script引用，执行webpack" class="headerlink" title="3.去掉html中的script引用，执行webpack"></a>3.去掉html中的script引用，执行webpack</h3><p>&emsp;&emsp;执行了webpack后，你会发现dist目录下多了个index.html，打开发现在body部分自动引入了bundle.js。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>&emsp;&emsp;本文总结了手动搭建react开发环境的步骤及部分注意点，尽管都是些基本配置，但不得不注意这个过程中多数的坑，只有经历了才知道。可能我的总结不尽完整，后续开发过程中配置肯定会越来越复杂，坑也会有的，先就这些吧。未完待续……</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2017/01/18/ScopeChain/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2017/01/18/ScopeChain/" itemprop="url">
                  关于作用域和作用域链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-18T16:38:10+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2017/01/18/ScopeChain/" class="leancloud_visitors" data-flag-title="关于作用域和作用域链">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;本来是计划写一下JS闭包的概念的。但发现要准确理解闭包的之前，必须要先弄明白几个重要的概念：</p>
<h2 id="一、执行环境"><a href="#一、执行环境" class="headerlink" title="一、执行环境"></a>一、执行环境</h2><hr>
<p>&emsp;&emsp;执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每一个执行环境都有一个与之关联的变量对象，用于保存执行环境中定义的变量和函数。要注意的是，<font color="red">执行环境和变量对象都是在执行函数的时候创建，而并非是在定义函数的时候创建的</font>。<br>&emsp;&emsp;当执行流进入到函数时，该函数的执行环境将被推入到一个环境栈中，等到函数执行完毕，其环境将被弹出并销毁，保存在其中的变量和函数也随之销毁，并把控制权交给之前的执行环境。<font color="red">这个环境栈其实就是作用域链</font>。</p>
<h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><hr>
<h3 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h3><p>&emsp;&emsp;•&ensp;所有在全局环境中定义的变量都拥有全局作用域。<br>&emsp;&emsp;•&ensp;所有未经声明的变量都是全局变量，拥有全局作用域。</p>
<h3 id="2、局部作用域"><a href="#2、局部作用域" class="headerlink" title="2、局部作用域"></a>2、局部作用域</h3><p>&emsp;&emsp;除了以上两种情况，其余的变量都是局部变量，局部变量一般位于函数或对象内部。<br>&emsp;&emsp;注意：尽量不要定义全局变量，因为全局变量可以被所有的函数和对象访问到，很可能引起属性冲突和全局环境污染。尤其是在团队项目当中，如果应用不恰当，很可能造成某个全局属性的值不知道是怎么来的。</p>
<h2 id="三、作用域链"><a href="#三、作用域链" class="headerlink" title="三、作用域链"></a>三、作用域链</h2><hr>
<p>&emsp;&emsp;作用域链保证对执行环境有权访问的所有变量和函数的有序访问。之前也提到过，执行环境组成的环境栈形成一个链式调用，最顶上的环境永远是当前执行流执行到的函数的执行环境。这也就是为什么说作用域链的最前端总是当前执行环境的变量对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/tomee/blog/2017/01/17/Inherit/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/tomee/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/tomee/blog/2017/01/17/Inherit/" itemprop="url">
                  JavaScript继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-17T15:59:50+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/tomee/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/tomee/blog/2017/01/17/Inherit/" class="leancloud_visitors" data-flag-title="JavaScript继承">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;前面总结了JS对象的创建，既然有对象的创建，自然就离不开继承，本篇将总结一下JS几种实现继承的方法：</p>
<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><hr>
<p>&emsp;&emsp;我们知道每个对象都有一个指定的原型对象，这个原型对象是可以被所有对象的实例访问到的，因此可以采用将子类的原型指针指向要继承的父类的实例。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=<span class="string">'male'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype=<span class="keyword">new</span> Parent(); <span class="comment">//继承</span></span><br><span class="line">Child.prototype.constructor=Child;</span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child();</span><br><span class="line">child.sayName();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种继承方式存在两个严重的问题：</p>
<blockquote>
<p>1、由于原型对象中的属性和方法可以被所有的实例共享，因此，假如某个属性值是个引用类型，比如：数组。那么当一个实例当中修改了数组的值，其余实例中的该属性值都会发生变化。这显然是不科学的；<br>2、子类在继承父类的时候，无法动态地给父类构造函数传递参数。因此，这种情况下即使子类继承到了父类的属性也没有意义，因为父类中的属性没办法取到值。你可能会说：我们可以在<code>Child.prototype=new Parent();</code>这一句的时候给父类属性赋值。但请注意，这一句只会执行一次，那就是在为Child重新指定原型对象的时候，而并不会在每次创建实例的时候执行。所以，即使在这一句能设值，那也是在创建实例时不能改变的。</p>
</blockquote>
<h2 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h2><hr>
<p>&emsp;&emsp;针对第一种继承方式的问题，第二种继承方式有所改善，构造函数继承方式可以向父类构造函数传递参数了。直接上代码说明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">    <span class="keyword">this</span>.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">// 继承</span></span><br><span class="line">    <span class="keyword">this</span>.sex=<span class="string">'male'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child(<span class="string">'Jerry'</span>,<span class="number">22</span>);</span><br><span class="line">child.sayAge(); <span class="comment">//22</span></span><br><span class="line">child.sayName(); <span class="comment">//Uncaught TypeError: child.sayName is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;把这段代码复制到控制台运行，结果是，可以弹出22，但运行到sayName()方法的时候，程序找不到sayName方法。尽管构造函数方式也能实现继承，但它的缺点也是显而易见的：</p>
<blockquote>
<p>1、存在于父类中的方法没办法实现共享，这跟创建对象时的构造函数方式有着相同的问题，每创建一个实例也要创建一份同样的方法，造成内存浪费<br>2、刚刚的报错已经提示很明显了，为什么会找不到sayName方法？因为子类实例根本无法访问到父类原型对象的属性和方法！</p>
</blockquote>
<h2 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h2><hr>
<p>&emsp;&emsp;组合继承，是由原型链继承和借用构造函数继承两种方式结合，取二者之所长形成的一种继承模式，因此叫做组合继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name+<span class="string">'，我的书：'</span>+<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype=<span class="keyword">new</span> Parent(); <span class="comment">//继承公用方法</span></span><br><span class="line">Child.prototype.constructor=Child;</span><br><span class="line"><span class="keyword">var</span> child1=<span class="keyword">new</span> Child(<span class="string">'tom'</span>,<span class="number">25</span>,<span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> child2=<span class="keyword">new</span> Child(<span class="string">'jerry'</span>,<span class="number">20</span>,<span class="string">'female'</span>);</span><br><span class="line">child2.book.push(<span class="string">'book4'</span>);</span><br><span class="line">child1.say(); <span class="comment">//我是tom，我的书：book1,book2,book3</span></span><br><span class="line">child2.say(); <span class="comment">//我是jerry，我的书：book1,book2,book3,book4</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;运行这段代码，你会发现，say方法是放在父类原型对象中的，程序可以正常访问到，而且，不同的实例各自有一份引用类型的实例，一个实例对数组的改变不会影响其他实例。这种模式就要求程序员在创建对象的写法上要规范了，如果我们把公用方法写在父类的构造函数中，无论我们采用哪种继承方式，都会有重复的方法被创建占用内存。<br>&emsp;&emsp;这种继承方式已经解决了之前提出的所有问题，算是继承中用得最多的一种模式。但它也并非最优，<strong>实际上我们调用了两次父类的构造函数：一次是在为子类创建原型对象的时候，另一次是在执行子类构造函数的时候也会调用父类的构造函数</strong>。</p>
<h2 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h2><hr>
<p>&emsp;&emsp;其实，仔细想想，我们执行<code>Child.prototype=new Parent();</code>这一句，无非就是想让子类的原型指针指向父类的原型对象嘛，那我们没必要创建父类的实例，我们只需要有一份父类原型对象的拷贝不就行了？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name+<span class="string">'，我的书：'</span>+<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> prototype=object(Parent.prototype); <span class="comment">//这里的prototype就是子类需要继承的原型对象**</span></span><br><span class="line">prototype.constructor=Child; <span class="comment">//把原型对象的constructor属性重新指向构造函数</span></span><br><span class="line">Child.prototype=prototype; <span class="comment">//将原型指针指向新的原型对象</span></span><br><span class="line"><span class="keyword">var</span> child1=<span class="keyword">new</span> Child(<span class="string">'tom'</span>,<span class="number">25</span>,<span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> child2=<span class="keyword">new</span> Child(<span class="string">'jerry'</span>,<span class="number">20</span>,<span class="string">'female'</span>);</span><br><span class="line">child2.book.push(<span class="string">'book4'</span>);</span><br><span class="line">child1.say(); <span class="comment">//我是tom，我的书：book1,book2,book3</span></span><br><span class="line">child2.say(); <span class="comment">//我是jerry，我的书：book1,book2,book3,book4</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种方式单独定义了一个object方法，这个方法返回一个空对象的实例，这个实例的原型指针指向Parent的原型对象。所以，我们只需要将子类的原型指针指向object方法返回的这个对象，就可以继承到父类的原型对象的方法和属性了。<br>&emsp;&emsp;这种方法避免了两次调用父类构造函数，用一个不包含任何自定义属性的对象来替代之前创建父类实例进行原型继承的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/tomee/blog/page/2/">2</a><a class="extend next" rel="next" href="/tomee/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/tomee/blog/images/avatar.gif" alt="Tomee">
          <p class="site-author-name" itemprop="name">Tomee</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/tomee/blog/archives">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/tomee/blog/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tomee/blog/tags">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/tomee-oy" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2088048923/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/ou-yang-de-cai" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-angellist"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://yuguo.us/" title="Yuguo" target="_blank">Yuguo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cnedwan.com/" title="Xuheng" target="_blank">Xuheng</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tomee</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/tomee/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/tomee/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/tomee/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/tomee/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/tomee/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/tomee/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/tomee/blog/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/tomee/blog/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/tomee/blog/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/tomee/blog/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/tomee/blog/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  
      
  

  




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("xUAzEcVj0ETQXIxIKTDo7aHM-gzGzoHsz", "sVrjzN8U2N1AhxFwcjLd8Cs9");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
