<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">












  
  
  <link href="/blog/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/blog/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/blog/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="欧阳德才">
<meta property="og:url" content="http://ouyangdecai.com/blog/index.html">
<meta property="og:site_name" content="欧阳德才">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欧阳德才">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://ouyangdecai.com/blog/">





  <title> 欧阳德才 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?41fc030db57d5570dd22f78997dc4a7e";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/blog/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">欧阳德才</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
    
      <p class="site-subtitle">day day no bug</p>
    
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/blog/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/blog/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/blog/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/blog/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2019/08/18/The-Moon-and-Sixpence/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2019/08/18/The-Moon-and-Sixpence/" itemprop="url">
                  关于《月亮和六便士》的思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-08-18T21:03:21+08:00">
                2019-08-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/书评/" itemprop="url" rel="index">
                    <span itemprop="name">书评</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2019/08/18/The-Moon-and-Sixpence/" class="leancloud_visitors" data-flag-title="关于《月亮和六便士》的思考">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;查尔斯•斯特里克兰，一个生活在英格兰的中产阶级家庭，他是两个孩子的父亲和一个貌美且高雅的女人的丈夫，他是一名股交所经纪人，社会地位虽谈不上顶层上流但也还算富庶。</p>
<p>&emsp;&emsp;某一天，他突然离开了这个家，无声无息，毫无征兆！他抛充妻子，放弃在别人眼里看来极其幸福的生活，只身一人来到巴黎，追寻他所谓的梦想。在“我”见到他之前，他的妻子艾美和姐夫安德鲁上校一度猜测他带着某个女人私奔去享受奢靡浮华的生活去了，后来“我”见到他的时候，他过着食不果腹，靠人接济的生活，在“我”到巴黎之前，斯特里克兰太太拜托我一定要带他回去，她可以原谅他的一切过错，只要他回去。但“我”最终没能说动一个把关的思想者。</p>
<p>&emsp;&emsp;五年后，“我”在巴黎又见到斯特里克兰，此时的他已经是一个破烂邋遢，不修边幅的糟老头，创作上也还是默默无闻。后来他生了一场大病差点死掉，幸亏好心人斯特罗夫央求斯特罗夫太太（布兰琪）答应把他接到自己家悉心照顾，他痊愈之时却夺走了斯特罗夫太太，但两个月后斯特罗夫太太为他而自尽，他表现得一如既往的冷静，尤如他当离开英国那个家一样冷漠。一个星期后，斯特里克兰去了马赛。</p>
<p>&emsp;&emsp;斯特里克兰在马赛过了四个多月凄惨的流浪生活，睡地板，当水手，做工人，只要能填饱肚子，有时间画画，他什么都干。幸运的是，他遇到了尼科尔斯船长，把他带到了他最终的归宿——塔希提岛。</p>
<p>&emsp;&emsp;在塔希提，似乎一切都是他理想的生活，在这里，没有人笑话他的绘画水平有多差，这里的人总是那么宽容，这里允许一切的可能性，你哪怕是一个执著的疯子。约翰逊太太（缇亚蕾）常常接济他，给他买画笔、颜料。经她撮合，斯特里克兰和爱塔结婚，他们育有一儿一女，并且搬到了爱塔父母留下的山林里去生活。这里有山有水，自给自足，三年时间过去了。。。</p>
<p>&emsp;&emsp;据库特拉医生所说，斯特里克兰得了麻风病。当斯特里克兰得知这件事时，没有什么使他沮丧，他只关心他还有多少日子，他沉浸在艺术的创作中。在接下来的两三年中，斯特里克兰从虚弱到失明到最后死去，在他尸体的房子里，库特拉医生在墙壁上发现了真正艺术的画作。但斯特里克兰留下遗言叫爱塔将其付之一炬随他而去。给后人留下的只有叹挽。</p>
<p>&emsp;&emsp;以上就是一个“艺术家”，甚至可以说是一个疯子的故事。斯特里克兰从不在乎别人怎么说他，哪怕别人笑话他的画作，他甚至不在乎他的画值多少钱，他更不会拿自己的画换钱。但哪怕好心帮他的约翰逊太太都还后悔当初没有花二十法郎买下他那些没人看得入眼的画作，否则如今已经价值连城可以发一笔不小的财了。还有他惨死以后，斯特里克兰太太还在利用他把自己包装成一个贤内助。在之前的美好生活中，斯特里克兰太太说他是个“庸俗的小市民”，她根本不把他看在眼里。我想，斯特里克兰突然离家出走去寻找人生的价值，与他太太的态度不无关系。他太太总想结识社会名流，将自己标榜成一个受过艺术熏陶的上层人士。</p>
<p>&emsp;&emsp;也许我真的没有成为艺术家的潜智，因为我无论如何都理解不了布兰琪为他自尽后他为何还能表现得那么冷漠，而且斯特罗夫不遗余力地帮助他，他却夺走了他妻子，他心里竟然连一丝的愧疚都没有！我并不认为毛姆在创作这部小说的时候是为了讴歌什么。一个人，无论他在艺术方面造诣多高，他都不能以任何名义去伤害任何人！斯特里克兰是个失职的父亲，也是一个不负责任的丈夫。他更没有理由把布兰琪的死当作若无其事，更何况她曾是一个把他从死亡边缘救回来的大恩人的妻子，他应该受到良心的谴责！</p>
<p>&emsp;&emsp;在读完小说后，我好奇为什么小说的结尾没有点题。《月亮和六便士》这个名字与小说到底是怎么联系起来的。后来查资料，月亮象征崇高的理想追求和美妙的精神境界，也象征着离开伦敦的斯特里克兰甘之如饴的清贫；六便士这种小面额的硬币代表着世俗的鸡虫得失与蝇头小利，也代表着卡迈克尔所引以为豪的豪奢。月亮和六便士之间应该如何取舍，毛姆并没给出答案。但我认为，斯特里克兰是一个人格分裂的存在，人不应该为了追求“月亮”而将“六便士”视为鄙夷。所以，“月亮”只是一个目标，“六便士”也并不世俗，而是我们每天面对的现实并亟待解决的问题，无需非此即彼。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2018/09/22/es5方式实现promise/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2018/09/22/es5方式实现promise/" itemprop="url">
                  es5方式实现promise
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-09-22T17:32:20+08:00">
                2018-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2018/09/22/es5方式实现promise/" class="leancloud_visitors" data-flag-title="es5方式实现promise">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于如何使用es5来实现es6中<code>promise</code>功能，重点在于创建<code>promise</code>的时候，它的回调函数是立即执行的，而其内部的<code>resolve</code>和<code>reject</code>方法又是通过<code>then</code>方法传进来的。那么，如何保证运行到调用成功或失败的操作时，其对应的回调函数是已经定义好了的呢？</p>
<p>&emsp;&emsp;创建promise对象时传进去的回调函数是立即执行的。为了保证在执行到成功或者失败的时候，其对应的回调函数已经定义了，我们可以借助<code>javascript</code>消息队列的特性来达到我们的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">this</span>.value = val</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		self.resolvedFun(self.value)</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">this</span>.value = val</span><br><span class="line">	setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		self.rejectedFun(self.value)</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = resolvedFun</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = rejectedFun</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法如下</span></span><br><span class="line"><span class="keyword">var</span> fn=<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'begin to execute!'</span>);</span><br><span class="line">  <span class="keyword">var</span> number=<span class="built_in">Math</span>.random();</span><br><span class="line">  <span class="keyword">if</span>(number&lt;=<span class="number">0.5</span>)&#123;</span><br><span class="line">    resolve(<span class="string">'less than 0.5'</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    reject(<span class="string">'greater than 0.5'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> MyPromise(fn);</span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'resolve: '</span>, data);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'reject: '</span>, data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>解释一下上面的代码：  </p>
<p>&emsp;&emsp;因为<code>MyPromise</code>的实例化和调用它的<code>then</code>方法，一前一后地被同步调用，在<code>MyPromise</code>内部的代码就要访问调用<code>then</code>方法时传进去的成功和失败的回调函数。如何才能让<code>then</code>方法中的回调函数“后来居上”呢？刚说了，<code>new MyPromise()</code>和<code>then</code>是一前一后的同步代码，也就是它们的执行是属于同一个事件循环的，我们只要把对失败或者成功的回调放到本次事件循环结束后再调用，就能保证在调用成功或者失败的操作时，它们的回调函数都是已经定义了的。所以我们在<code>resolve</code>和<code>reject</code>的实现中采用了<code>setTimeout</code>包装，在调用<code>then</code>方法的时候，将实例的<code>resolvedFun</code>和<code>rejectedFun</code>方法指向传进来的成功和失败的函数。<code>setTimeout</code>在本轮循环结束后才执行，所以，其内部要访问的<code>resolvedFun</code>和<code>rejectedFun</code>是早就被指定好的，这样，整个流程就已经完整了。</p>
<p>&emsp;&emsp;接下来就是给<code>MyPromise</code>加状态，我们知道es6中的<code>promise</code>一旦状态确定后就不会再被更改了。在上面的例子中成功和失败的结果都会被输出，这是不合理的。所以将<code>MyPromise</code>做如下修改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.status=<span class="string">'pending'</span></span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.resolvedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status == <span class="string">'reject'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.rejectedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = resolvedFun</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = rejectedFun</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改过后再调用，就只会输入一组结果了，要么成功，要么失败。<br>接下来就是要实现<code>MyPromise</code>的链式调用功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyPromise</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.value</span><br><span class="line">	<span class="keyword">this</span>.status=<span class="string">'pending'</span></span><br><span class="line">	<span class="keyword">this</span>.resolvedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	<span class="keyword">this</span>.rejectedFun = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">	fn(<span class="keyword">this</span>.resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>.reject.bind(<span class="keyword">this</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.resolve = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status = <span class="string">'resolve'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.resolvedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.reject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">this</span>.status == <span class="string">'pending'</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.status == <span class="string">'reject'</span></span><br><span class="line">		<span class="keyword">this</span>.value = val</span><br><span class="line">		setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			self.rejectedFun(self.value)</span><br><span class="line">		&#125;, <span class="number">0</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPromise.prototype.then = <span class="function"><span class="keyword">function</span>(<span class="params">resolvedFun, rejectedFun</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">var</span> self = <span class="keyword">this</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve_next, reject_next</span>)</span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">resolvedFunWrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> result = resolvedFun(self.value)</span><br><span class="line">			resolve_next(result)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">rejectedFunWrap</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="keyword">var</span> result = rejectedFun(self.value)</span><br><span class="line">			reject_next(result)</span><br><span class="line">		&#125;</span><br><span class="line">		self.resolvedFun = resolvedFunWrap</span><br><span class="line">		self.rejectedFun = rejectedFunWrap</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;之前的<code>then</code>方法很简单，只需要将成功和失败的回调函数赋给<code>MyPromise</code>实例的两个对应方法即可。但要实现链式调用的话，首先证明<code>then</code>方法返回的是一个<code>MyPromise</code>对象，其次就是本次成功或失败的结果要作为下一次成功或失败调用的函数的参数传进去。所以要对外层传进来的成功和失败的回调函数进行包装。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2018/08/15/前后端跨域解决方案/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2018/08/15/前后端跨域解决方案/" itemprop="url">
                  前后端跨域解决方案
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-15T21:28:56+08:00">
                2018-08-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2018/08/15/前后端跨域解决方案/" class="leancloud_visitors" data-flag-title="前后端跨域解决方案">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="1、问题描述"><a href="#1、问题描述" class="headerlink" title="1、问题描述"></a>1、问题描述</h4><p>为了避免前后端在联调的时候，遇到问题时前端都要在本机上修改然后再打包到服务器上调试。经过实践，现给出CORS（跨域资源共享）解决方案：</p>
<h4 id="2、解决方案"><a href="#2、解决方案" class="headerlink" title="2、解决方案"></a>2、解决方案</h4><blockquote>
<p>1.仅仅是跨域请求  </p>
</blockquote>
<ul>
<li>前端设置</li>
</ul>
<p>前端如果是用的es6框架，则需要在mock中补充如下配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	crossDomain: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端设置</li>
</ul>
<p>如果仅仅是为了解决跨域问题，后端则需要在每次请求时拦截，并在响应头中设置</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>2.既要跨域，又要携带cookie</p>
</blockquote>
<p>这种情况就不仅仅需要后端设置了，前后端必须同时设置  </p>
<ul>
<li>前端设置</li>
</ul>
<blockquote>
<p>ES6框架中采用的是<code>jquery</code>的<code>ajax</code>请求数据，需要在<code>mock</code>中做如下补充：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	crossDomain: <span class="literal">true</span>,</span><br><span class="line">	xhrFields: &#123;</span><br><span class="line">		withCredentials: <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>react框架中采用的是axios请求，需要在mock中做如下补充：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config: &#123;</span><br><span class="line">	withCredentials: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后端配置</li>
</ul>
<p>既要跨域，又要携带cookie，后端的<code>Access-Control-Allow-Origin</code>就不能显示设置为<em>了，它需要搭配另一个<code>Access-Control-Allow-Credentials</code>使用，并且其值为<code>true</code>。为了使<code>Access-Control-Allow-Origin</code>具有通用性并且不能为\</em> ，那么可以通过从request中动态获取当前的请求源来解决这个问题。所以，后端配置如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Origin"</span>, request.getHeader(<span class="string">"Origin"</span>));</span><br><span class="line">response.setHeader(<span class="string">"Access-Control-Allow-Credentials"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2018/04/15/React-Context-API解读/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2018/04/15/React-Context-API解读/" itemprop="url">
                  React Context API解读
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-15T10:45:26+08:00">
                2018-04-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2018/04/15/React-Context-API解读/" class="leancloud_visitors" data-flag-title="React Context API解读">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、为什么需要context-api"><a href="#一、为什么需要context-api" class="headerlink" title="一、为什么需要context api"></a>一、为什么需要context api</h3><p>–<br>在react开发过程中，我们可能会遇到这样的需求：某组件需要将值传给它的孙子，甚至嵌套更深的后代组件，如果不考虑context api，我们的实现方式，便是采用props逐层向下传递，直到需要获取到值的组件为止：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">	  <span class="keyword">return</span> &lt;Parent text='我是一个跨组件变量传递示例'/&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间层组件 parent.js</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">	constructor(props)&#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return &lt;Child text=&#123;this.props.text&#125;/&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要获取顶层组件的text值的底层组件 child.js</span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">	constructor(props)&#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return this.props.text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，应该肯定的是这种方式是可以实现的。但是一旦嵌套层数太多，在每一层组件里都要用<code>this.props</code>去接收上层组件传来的变量，那么，你的代码将陷入链式地狱，并且变得难以维护。由此，context api应运而生。</p>
<h3 id="二、旧版context-api"><a href="#二、旧版context-api" class="headerlink" title="二、旧版context api"></a>二、旧版context api</h3><p>–<br>关于context api是用来干什么的，在上一部分实际已经阐述出来了：解决跨组件数据传递的问题。在context api中，我们只需要在数据提供者（即顶层组件）中宣称：“本宝宝可以提供你们想要的xxx数据。”，然后在需要数据的组件中“回应”称：“本大大需要你的数据，请给我一份。”即可完成一次完整的跨组件数据传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	getChildContext()&#123;</span><br><span class="line">		<span class="keyword">return</span> &#123;</span><br><span class="line">			text: <span class="string">'我是旧版context api示例'</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> &lt;Parent /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">GrandParent.childContextTypes = &#123;</span><br><span class="line">	text: PropTypes.string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 中间层组件 parent.js</span><br><span class="line">class Parent extends Component&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return &lt;Child /&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 需要获取顶层组件的text值的底层组件 child.js</span><br><span class="line">import PropTypes from 'prop-types'</span><br><span class="line">class Child extends Component&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		return this.context.text</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">Child.contextTypes = &#123;</span><br><span class="line">	text: PropTypes.string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>较于props的传递方式，context api不用在每个中间层组件中都显示地将props中的text设置到子组件的属性中，对于跨组件的数据传递确实提供了方便。但这种方式的缺陷在于：由于中间层组件并不依赖于context的存在，如果中间层某个组件采用<code>shouldComponentUpdate</code>做组件优化，限制了组件更新的条件，而组件更新只与props、state有关，与context并无关系。所以，顶层组件更新，可能导致底层组件并不会更新。</p>
<h3 id="三、新版context-api"><a href="#三、新版context-api" class="headerlink" title="三、新版context api"></a>三、新版context api</h3><p>–<br>新版context api从形式上来看，更符合react风格：组件化的处理方式，用Provider来包裹顶层组件，用Consumer来包裹底层获取数据的组件，同样是宣称“本宝宝可以提供数据”，也同样是“本大大需要你的数据”，新版api不再像旧版本那样对组件产生额外的除生命周期以外的钩子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建供全局使用的context store.js</span></span><br><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">const</span> context = React.createContext()</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = context.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = context.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顶层组件 grandParent.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"><span class="keyword">const</span> store = &#123;</span><br><span class="line">  text: <span class="string">'新版context api示例'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GrandParent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;Provider value = &#123;store&#125;&gt;</span><br><span class="line">        &lt;MsgContainer /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Provider&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 中间层组件 parent.js</span></span><br><span class="line"><span class="regexp">class Parent extends Component&#123;</span></span><br><span class="line"><span class="regexp">	render()&#123;</span></span><br><span class="line"><span class="regexp">		return &lt;Child /</span>&gt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要获取顶层组件的text值的底层组件 child.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; Consumer &#125; <span class="keyword">from</span> <span class="string">'./store.js'</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">	render()&#123;</span><br><span class="line">		<span class="keyword">return</span> (</span><br><span class="line">			&lt;Consumer&gt;</span><br><span class="line">        &#123;</span><br><span class="line">          context =&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> context.text</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;<span class="regexp">/Consumer&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">	&#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>实际上，新版的context api仍然存在缺陷。假如某个组件要获取的数据有多个数据来源，那么，其组件结构类似以下的形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;A&gt;</span><br><span class="line">	&lt;B&gt;</span><br><span class="line">		&lt;C&gt;</span><br><span class="line">			...</span><br><span class="line">		&lt;<span class="regexp">/C&gt;</span></span><br><span class="line"><span class="regexp">	&lt;/</span>B&gt;</span><br><span class="line">&lt;<span class="regexp">/A&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>是不是很熟悉的嵌套地狱！如果真的遇到这种需求，我们应该依赖于第三方框架类似redux、mobx等来实现。这些框架的底层实际上也是用context api来实现的。</p>
<h3 id="四、redux将被取代？"><a href="#四、redux将被取代？" class="headerlink" title="四、redux将被取代？"></a>四、redux将被取代？</h3><p>–<br>社区有人讨论说，随着context api的优化，会不会导致redux被丢弃？答案是：不会！因为无论是新版的context api还是旧版的context api，解决的都是跨层级组件间的数据传递的问题。原生的context api并不能强大到做系统级的数据管理。所以，context api只是让我们理解原理，真正的应用，正是这些强大的框架赋予我们的力量！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/11/04/selections/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/11/04/selections/" itemprop="url">
                  selections工作原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-11-04T21:23:10+08:00">
                2017-11-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/11/04/selections/" class="leancloud_visitors" data-flag-title="selections工作原理">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>原文链接：<a href="https://bost.ocks.org/mike/selection/" target="_blank" rel="noopener">https://bost.ocks.org/mike/selection/</a></p>
<p>以前，我对D3的选择集有过一些简单的描述，其中的讲解仅限于入门。 这篇文章以更加全面的方式讲解如何使用选择集，我会说明选择集是如何执行的。这篇文章有点长，但它将消除你的诸多疑虑并助你掌握数据驱动文档（Data-Drive Documents）。</p>
<p>这篇文章的开头似乎让人觉得有点随意，它讲述的是selections的内部工作原理而并非设计的动机，因此你可能会疑问为什么要以这种方式呈现。很简单，在解释所有东西是如何工作之前，先把所有的东西放在一起比较容易。等你读到最后，设计意图和功能也逐渐清晰。</p>
<p>D3是一个可视化库，因此这篇文章会伴随讲解一些可视化方面的知识。在下面的示意图中，左边的图将会展示selections的结构，右边的图将会展示数据结构。<br><img src="../dist/blog/dist/2017/11/04/selections/join.jpg" alt></p>
<p>圆角矩形比如：<span style="background:rgb(217,217,217);padding:3px 5px;border-radius:5px;">thing</span>表示各种类型的JavaScript对象，包括对象字面量，数字组成的数组以及DOM元素。确定的对象类型用不同的颜色标识，包括<span style="border:1px solid rgb(227,86,33);padding:3px 5px;border-radius:5px;">selection</span>、<span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">array</span>以及<span style="background:rgb(185,185,185);padding:3px 5px;border-radius:5px;">element</span>。从一个对象到另一个对象的引用用关联线来表示（——）。比如，一个包含数字42的数组是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array = [42];</span><br></pre></td></tr></table></figure>
<p><span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">array</span>——<span style="background:rgb(217,217,217);padding:3px 5px;border-radius:5px;">42</span></p>
<p>只要有可能，生成给定选择集的代码就会立即出现在图的上方。打开浏览器的JavaScript控制台并以交互方式创建选择集是测试你对文本理解的好方法！</p>
<p>~正文从这里开始</p>
<h3 id="一、数组的子类"><a href="#一、数组的子类" class="headerlink" title="一、数组的子类"></a>一、数组的子类</h3><p>你可能会说，选择集不就是DOM元素组成的数组嘛！错！一方面，选择集是数组的一个子类，这个子类提供了操作被选中的selections的方法，比如说设置属性和样式。选择集同样继承数组的原生方法，比如说array.forEach及array.map。然而，你将很少用到数组的原生方法，因为D3提供了更加便利的替代方案，比如selection.each(为了适应selections的书写规范，少许几个原生方法被D3重写了，即selection.filter和selection.sort)。</p>
<h3 id="二、分组元素"><a href="#二、分组元素" class="headerlink" title="二、分组元素"></a>二、分组元素</h3><p>选择集不同于数组的另一个原因是，选择集是元素的数组的数组：一个选择集是一个包含众多分组的数组，并且每一个分组是一个包含众多元素的数组。比如’d3.select‘方法返回一个group的集合，而这个group包含的是被选中的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selection = d3.select(&quot;body&quot;);</span><br></pre></td></tr></table></figure>
<p><span style="border:1px solid rgb(227,86,33);padding:3px 5px;border-radius:5px;">select</span> —— <span style="border:1px solid rgb(97,97,97);padding:3px 5px;border-radius:5px;">group</span> —— <span style="background:rgb(185,185,185);padding:3px 5px;border-radius:5px;">body</span></p>
<p>在javascript控制台，试着运行这段代码，并且查看一下分组selection[0]以及节点<code>selection[0][0]</code>。D3的API提供了直接访问节点的入口，最为常见的是使用selection.node。</p>
<p>同样的，d3.selectAll返回一个组和任何数量的元素的选择集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;h2&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/1.jpg" alt></p>
<p>d3.select和d3.selectAll返回的选择集都有一个组，获取包含多个组的选择集的唯一方法是selection.selectAll。比如，如果你要选择一张表的所有的行元素，并且随后选择每一行的所有单元格，你会获取到一组包含多个单元格的group分组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;tr&quot;).selectAll(&quot;td&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/2.gif" alt></p>
<p>通过selectAll，旧的选择集中的每一个元素都会在新的选择集中变成一个分组；每个组包含一个旧元素及其匹配的后代元素。因此，如果每个单元格中包含一个’span’元素，并且你后续进行第三次selectAll调用，你将得到一个包含16个分组的选择集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;tr&quot;).selectAll(&quot;td&quot;).selectAll(&quot;span&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/3.gif" alt></p>
<p>每个组都有一个parentNode属性，用于存储所有组元素的共享父元素。父元素在创建组的时候被设置，如果你调用d3.selectAll(“tr”).selectAll(“td”)，返回的选择集是包含td元素的分组，它们的父节点是tr元素。对于d3.select和d3.selectAll方法返回的结果集，它们的父元素是html。</p>
<p>更多时候，你可以忽略那些被分组的选择集。当你给attr或者style赋值为一个函数时，这个函数会被选择集中的每一个元素调用，分组和元素集最主要的区别在于函数的第二个参数i，i表示的是组内的索引而并非选择集内索引。</p>
<h3 id="三、非分组操作"><a href="#三、非分组操作" class="headerlink" title="三、非分组操作"></a>三、非分组操作</h3><p>只有selectAll可以产生分组行为，select保留现有分组。select方法不同，因为每个元素的选择中只有一个元素。因此，select会将数据从父节点传送到子节点，而selectAll不会！</p>
<p>append和insert方法是基于select之上的包装，所以它们也会保存分组及传送数据。比如：给一个document添加4个section元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/4.jpg" alt></p>
<p>如果你给每个section元素添加一个p元素，新的选择集同样只有唯一一个分组</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;).append(&quot;p&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/5.jpg" alt></p>
<p>注意：这个selectAll选择集的parentNode依然是html元素，因为selection.selectAll被调用并不会导致重新分组</p>
<h3 id="四、空元素"><a href="#四、空元素" class="headerlink" title="四、空元素"></a>四、空元素</h3><p>分组可以包含null以表示丢失的元素，null元素被众多操作所忽略；比如，D3在设置属性和样式的时候会跳过null元素。</p>
<p>当selection.select不能找到和给定选择器相匹配的元素时，就会产生null元素。select方法必须维持既有的分组结构，所以会用null来占位。比如，如果在上面的例子中只有最后两人个section元素中含有aside元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;section&quot;).select(&quot;aside&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/6.jpg" alt></p>
<p>和分组一样，你可以忽略null空元素。不过你要注意的是，null空元素依然维持着它的分组结构以及它的组内索引。</p>
<h3 id="五、数据绑定"><a href="#五、数据绑定" class="headerlink" title="五、数据绑定"></a>五、数据绑定</h3><p>令人意外的是，data并不是选择集的属性，而是其元素的属性。这意味着当你给选择集绑定数据集时，数据是被存储在DOM元素上的，而不是存储在选择集里（数据被存储在元素的一个叫做<code>__data__</code>的属性中）。如果一个元素没有这个属性，则其关联数据为undefined。因此数据是持久的而选择集可以被看作是暂时的（你可以重新选择DOM中的元素，并保留着之前绑定的数据）。</p>
<p>数据可以通过以下几种方式被绑定到元素上：</p>
<blockquote>
<p>1.通过selection.data将数据绑定到元素上；</p>
</blockquote>
<blockquote>
<p>2.通过selection.datum分配给各个元素；</p>
</blockquote>
<blockquote>
<p>3.通过append、insert或select从父元素继承数据绑定</p>
</blockquote>
<p>虽然没有必要直接设置<code>__data__</code>属性，可以使用selection.datum来绑定，但这样做可以说明如何实现数据绑定：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.body.__data__ = 42;</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/7.jpg" alt></p>
<p>相当于选择body元素并为它绑定数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.select(&quot;body&quot;).datum(42);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/8.jpg" alt></p>
<p>如果我们现在在body元素下面再添加一个元素，那么其子元素会自动继承来自父元素的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.select(&quot;body&quot;).datum(42).append(&quot;h1&quot;);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/9.jpg" alt></p>
<p>以上阐明了最后一种绑定数据的方法，在进一步的探索之前，我们必须回答更具现实意义的问题。</p>
<h3 id="六、什么是数据"><a href="#六、什么是数据" class="headerlink" title="六、什么是数据"></a>六、什么是数据</h3><p>D3中的数据可以是任何值的数组。比如，数值型数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [4, 5, 18, 23, 42];</span><br></pre></td></tr></table></figure>
<p>或者包含对象的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var letters = [</span><br><span class="line">  &#123;name: &quot;A&quot;, frequency: .08167&#125;,</span><br><span class="line">  &#123;name: &quot;B&quot;, frequency: .01492&#125;,</span><br><span class="line">  &#123;name: &quot;C&quot;, frequency: .02780&#125;,</span><br><span class="line">  &#123;name: &quot;D&quot;, frequency: .04253&#125;,</span><br><span class="line">  &#123;name: &quot;E&quot;, frequency: .12702&#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>甚至包含数组的数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var matrix = [</span><br><span class="line">  [ 0,  1,  2,  3],</span><br><span class="line">  [ 4,  5,  6,  7],</span><br><span class="line">  [ 8,  9, 10, 11],</span><br><span class="line">  [12, 13, 14, 15]</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>我们可以通过可视化呈现选择集与数据的映射关系，这里有一个5个数字的简单数组：<br><img src="../dist/blog/dist/2017/11/04/selections/10.jpg" alt></p>
<p>就像selection.style使用一个常量字符串来为每一个选定的元素定义一个统一的样式属性，或者通过函数来返回每个元素的动态样式(<code>function(d) {return d.color; }</code>)，selection.data可以接受一个常量值或一个函数。</p>
<p>然而，与其他的选择集方法不同，selection.data为每个组定义数据而不是每个元素（数据被表示为与组对应的数组，或是返回类似数组的函数。因此，一个被分组的选择集具有相应的分组数据）<br><img src="../dist/blog/dist/2017/11/04/selections/11.jpg" alt></p>
<p>图中的蓝线表明返回关联数组的函数，数据函数传递组的父元素的数据(d)及其组内索引(i)，并返回你想要加入组内的所有数据的数组。因此，数据通常表示的是绑定到父元素的数据函数，便于从分层数据创建分层DOM元素。</p>
<p>对于只有一个组的选择，可以直接将相应的单个数组传递给selection.data；你只有在将不同的数据绑定到不同分组的时候才需要函数操作</p>
<h3 id="七、关键知识点"><a href="#七、关键知识点" class="headerlink" title="七、关键知识点"></a>七、关键知识点</h3><p>要将数据和元素关联，我们必须知道哪个元素对应哪个数据，这归功于一组配对的键，一个键是一个标识字符串，比如说名称，当一个数据的键和元素的键相等时，这个数据就被分配给对应的这个元素。</p>
<p>索引是分配键最简单的方式（第一个数据和第一个元素有相同的键“0”，第二个数据和第二个元素有相同的键“1”，依次类推……）。将一组数据连接到匹配的paragraph元素数组，因此看起来像这样，键显示为绿色：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var numbers = [4, 5, 18, 23, 42];</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/12.jpg" alt></p>
<p>现在，选择的结果集就是绑定到数据的元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;div&quot;).data(numbers);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/13.jpg" alt></p>
<p>如果你的数据和元素都是按照既定的顺序排列的，那么按照索引匹配无疑是最方便的。然而，当顺序不同的时候，按照索引匹配不再可取！在这个例子中，你可以指定一个键函数作为data方法的第二个参数传进去。键函数返回指定的数据或元素的键值，如果你的数据是包含对象的数据，而每个对象都有一个name属性，你的键函数就可以返回关联的name：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var letters = [</span><br><span class="line">  &#123;name: &quot;A&quot;, frequency: .08167&#125;,</span><br><span class="line">  &#123;name: &quot;B&quot;, frequency: .01492&#125;,</span><br><span class="line">  &#123;name: &quot;C&quot;, frequency: .02780&#125;,</span><br><span class="line">  &#123;name: &quot;D&quot;, frequency: .04253&#125;,</span><br><span class="line">  &#123;name: &quot;E&quot;, frequency: .12702&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">function name(d) &#123;</span><br><span class="line">  return d.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/14.jpg" alt></p>
<p>由此，所选元素现在绑定到数据。 这些元素也被重新排序以匹配数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d3.selectAll(&quot;div&quot;).data(letters, name);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/15.jpg" alt></p>
<p>对于大型分组选择，这个过程可能相当复杂。但由于每个分组独立关联，因此被简化。因此，你只需要担心组内的唯一键，而不是整个选择集。<br><img src="../dist/blog/dist/2017/11/04/selections/16.jpg" alt></p>
<p>上面的例子假设数据和元素之间有一个精确的1：1匹配。 但是，如果给定的数据没有匹配的元素，或给定的元素没有匹配的数据，会发生什么？</p>
<h3 id="八、Enter、Update及Exit"><a href="#八、Enter、Update及Exit" class="headerlink" title="八、Enter、Update及Exit"></a>八、Enter、Update及Exit</h3><p>当按键将元素加入数据时，有三种可能的逻辑结果：</p>
<p>1、Update-对于给定的数据能找到匹配的元素</p>
<p>2、Enter-对于给定的数据不能找到匹配的元素</p>
<p>3、Exit-对于给定的元素找不到匹配的数据</p>
<p>以上就是由selection.update、selection.enter、selection.exit各自返回的三类结果集。想象一下，你有一个字母表的前五个字母的条形图(ABCDE)，你想过渡到你最喜欢的五个元音(YEAOI)，你可以使用键功能在转换中保持字母之间的关联，从而产生以下数据连接：<br><img src="../dist/blog/dist/2017/11/04/selections/17.jpg" alt></p>
<p>之前显示的两个字母（A和E）是元音，这些条形按照新数据的顺序放置在更新选项中：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var div = d3.selectAll(&quot;div&quot;).data(vowels, name);</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/18.gif" alt></p>
<p>另外三个显示的字母（B，C和D）是辅音，因此在新数据集中没有相应的数据。 这些元素因此被放置在Exit选择集中。 请注意，Exit选择集会保留原始选择的顺序，在移除之前进行动画制作时，此选项有时很有用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.exit();</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/19.gif" alt></p>
<p>最后，三个元音（Y，O和I）以前没有显示，因此没有相应的元素。 这些形成了Enter选择集：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.enter();</span><br></pre></td></tr></table></figure>
<p><img src="../dist/blog/dist/2017/11/04/selections/20.gif" alt></p>
<p>Update和Exit是常用的选择集，Enter则是选择集的一个子集。这是必要的，因为它代表了还不存在的元素，Enter选择集包含了占位符而并非实际存在的DOM元素，这些占位符只是具有<code>__data__</code>属性的对象。当后续插入节点时，这些新节点会替换原有的占位符而成为Enter中的新成员。</p>
<h3 id="九、合并Enter和Update"><a href="#九、合并Enter和Update" class="headerlink" title="九、合并Enter和Update"></a>九、合并Enter和Update</h3><p>数据的一般更新模式是添加缺省的元素并移除多余的元素，同时修改更新元素的动态属性、样式以及其他属性。通常，更新和缺省元素的属性之间有重叠。</p>
<p>为了减少重复的代码，enter.append有一个方便的附加功能：它使用enter选择集中新创建的元素替换update选择集中的null。因此，在enter.append之后，update选择集被修改为包含enter和update元素。 随后update选择集就包含所有当前显示的元素：<br><img src="../dist/blog/dist/2017/11/04/selections/21.jpg" alt></p>
<p>自此，数据关联的生命周期就完成了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/03/22/js-node-operation/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/22/js-node-operation/" itemprop="url">
                  js关于节点操作的问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-22T08:43:01+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/03/22/js-node-operation/" class="leancloud_visitors" data-flag-title="js关于节点操作的问题">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>刚看到原生js操作节点这部分，于是动手敲了几行代码练习一下节点操作方法的应用。真没想到还遇到了一个棘手的问题，下面进入正题：<br>首先，我在body里边简单写了个无序列表，如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"list"</span> <span class="attr">style</span>=<span class="string">"list-style:none;"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>C<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>C++<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>JAVA<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>JavaScript<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后，我在js里边都干了些什么呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa_text=<span class="built_in">document</span>.createTextNode(<span class="string">'python'</span>);</span><br><span class="line">suanfa.appendChild(suanfa_text);</span><br><span class="line">ul.insertBefore(suanfa,ul.lastChild);</span><br><span class="line"><span class="keyword">var</span> nodes=ul.children;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第1句获取ul的DOM对象，第2句到第4句创建了一个新的li节点，并为它添加了文本“python”，然后把新节点插入在了ul的倒数第2个子节点上。最后，循环输出每个子节点信息。此时，机智的你是不是会认为，下面就是输出结果：<br><img src="../dist/blog/dist/2017/03/22/js-node-operation/1.png" alt="第1次测试输出结果"><br>然而，并不是！！！真正的输出结果是下面这个：<br><img src="../dist/blog/dist/2017/03/22/js-node-operation/2.png" alt="第2次测试输出结果"><br>纳尼？？？你是不是也在想，明明是在lastChild进行的insertBefore，为什么python还是排到最后一个去了？我之前也想不明白，直到我把var nodes=ul.children换成了childNodes，再打印出来，请看：<br><img src="../dist/blog/dist/2017/03/22/js-node-operation/2.png" alt="childNodes获取的结果集"><br>这一看结果，相信你也就明白了。尽管我们知道，节点的children属性不会获取文本节点，而childNodes会获取文本节点。但不曾想过，js的节点插入操作将非元素结点也算作子节点的！所以，我上面的insertBefore不过是在最后那个#text元素前面插入了一个li元素，显示的时候，它还是所有li元素当中的最后一个，因此出现了之前那个问题。</p>
<p>解决方案：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul=<span class="built_in">document</span>.getElementById(<span class="string">'list'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa=<span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</span><br><span class="line"><span class="keyword">var</span> suanfa_text=<span class="built_in">document</span>.createTextNode(<span class="string">'python'</span>);<span class="keyword">debugger</span>;</span><br><span class="line">suanfa.appendChild(suanfa_text);</span><br><span class="line">ul.insertBefore(suanfa,ul.children[ul.children.length<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">var</span> nodes=ul.children;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>,len=nodes.length;i&lt;len;i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(nodes[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即，将insertBefore的第二个参数换成ul.children[ul.children.length-1]，实际上就是利用children属性只返回节点，不获取属性和文本的特性，以此获取最后一个子元素对象，再插件元素。其实，理解了以后就会发现，这种情况也就是在正数第2个位置和倒数第2个位置插入元素会产生异常（前提是除了li没有别的元素）。</p>
<p>最后，关于#text的一些思考：哪些情况下会产生#text文本节点？jQuery中的befor和after方法是怎样封装的？望各位大大多多指点。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/03/18/build-react-babel-webpack-environment/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/03/18/build-react-babel-webpack-environment/" itemprop="url">
                  手动创建react+babel+webpack开发环境
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-03-18T12:46:22+08:00">
                2017-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/环境搭建/" itemprop="url" rel="index">
                    <span itemprop="name">环境搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/03/18/build-react-babel-webpack-environment/" class="leancloud_visitors" data-flag-title="手动创建react+babel+webpack开发环境">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;从年前到现在一直在找工作，也由于家里的一些事情耽搁。所以，搁置已久的日志，是时候重新拾起记录了。由于之前在项目中尽量用的脚手架，甚至有些小项目根本就没有搭建什么框架。于是，今天琢磨了一下全手动搭建react+webpack+babel开发环境。一方面填坑，另一方面借此机会熟悉一下这些工具的API。以下正文：</p>
<h2 id="一、npm初始化"><a href="#一、npm初始化" class="headerlink" title="一、npm初始化"></a>一、npm初始化</h2><blockquote>
<p>npm init</p>
</blockquote>
<p>&emsp;&emsp;npm是时下相对流行的包管理器,使用此命令创建package.json文件，这个文件包含了项目中所有包的版本信息、依赖关系等。</p>
<h2 id="二、安装webpack"><a href="#二、安装webpack" class="headerlink" title="二、安装webpack"></a>二、安装webpack</h2><blockquote>
<p>npm install webpack -g</p>
</blockquote>
<p>&emsp;&emsp;安装完成后，在项目根目录创建一个webpack.config.js用于配置webpack。一定要全局安装。</p>
<h3 id="1-entry"><a href="#1-entry" class="headerlink" title="1.entry"></a>1.entry</h3><p>&emsp;&emsp;用于配置项目入口文件</p>
<h3 id="2-output"><a href="#2-output" class="headerlink" title="2.output"></a>2.output</h3><p>&emsp;&emsp;用于配置打包后文件的去向。其中，filename表示打包后的js叫什么名字，path表示打包后的文件所在的目录。如：<code>path=__dirname+&quot;/dist&quot;,filename=&quot;bundle.js&quot;</code>表示执行package打包后，在项目根目录下会新建一个dist文件夹，其中包含一个bundle.js文件，这个文件就是打包后的js。</p>
<h3 id="3-devServer"><a href="#3-devServer" class="headerlink" title="3.devServer"></a>3.devServer</h3><blockquote>
<p>npm install –save-dev webpack-dev-server</p>
</blockquote>
<p>&emsp;&emsp;用于配置webpack服务器。这部分配置比较关键，这是webpack提供的热更新功能，即时修改，即时出效果。其中比较主要的几个配置有：</p>
<blockquote>
<p><strong>conentBase</strong>。服务器启动后访问的根目录，比如：<code>contentBase:&quot;./dist&quot;</code>表示服务器开启后访问的是当前项目下的dist目录。<br><strong>inline</strong>。其值为布尔值，如果设置为true，表示开启热更新功能。否则不开启。<br><strong>port</strong>。用于设置服务端口，默认是8080。<br><strong>historyApiFallback</strong>。布尔值，这个属性设置在spa项目开发中非常有用，如果设置为true，所有的跳转将指向index.html</p>
</blockquote>
<p>注意：<br>&emsp;&emsp;1.webpack-dev-server指令用于启动webpack服务器，如果在后面加上<code>--content-base</code>表示服务器启动后访问devServer配置中contentBase指定的目录。如果为缺省值，表示访问当前项目的根目录。<br>&emsp;&emsp;2.“__dirname”是node.js中的一个全局变量，它指向当前执行脚本所在的目录。</p>
<h3 id="4-loaders配置"><a href="#4-loaders配置" class="headerlink" title="4.loaders配置"></a>4.loaders配置</h3><p>&emsp;&emsp;loaders配置写在module模块下。通过使用不同的loader，webpack通过调用外部的脚本或工具可以对各种各样的格式的文件进行处理，比如说分析JSON文件并把它转换为JavaScript文件，或者说把下一代的JS文件（ES6，ES7)转换为现代浏览器可以识别的JS文件。或者说对React的开发而言，合适的Loaders可以把React的JSX文件转换为JS文件。其中主要的配置属性有：</p>
<blockquote>
<p><strong>test</strong>。一个匹配loaders所处理的文件的拓展名的正则表达式（必须）。如：<code>test:&quot;/\.jsx$/&quot;</code>表示匹配所有的jsx语法，还有json、js、img、css、less、scss等文件格式匹配。<br><strong>loader</strong>。指定loader名称。如： <code>babel、json、babel-loader、css-loader、style-loader</code>等。<br><strong>include/exclude</strong>。手动指定包含/不包含的文件或文件夹。如：node_modules中的文件一般是不需要我们用loader进行转换的，可以手动排队这个文件夹下的所有文件。使用<code>exclude:/node_modules/</code><br><strong>query</strong>。一些额外的配置。</p>
</blockquote>
<h2 id="三、babel安装和配置"><a href="#三、babel安装和配置" class="headerlink" title="三、babel安装和配置"></a>三、babel安装和配置</h2><blockquote>
<p>npm install –save-dev babel-core babel-loader babel-preset-es2015 babel-preset-react</p>
</blockquote>
<p>&emsp;&emsp;<code>babel-core</code>是babel的核心库，babel-loader是jsx的loader,babel-preset-es2015是es6的转换器，babel-preset-react是react的语法转换器。<br>&emsp;&emsp;配置babel有两种方式：</p>
<h3 id="1-在webpack的loader里配置"><a href="#1-在webpack的loader里配置" class="headerlink" title="1.在webpack的loader里配置"></a>1.在webpack的loader里配置</h3><p>&emsp;&emsp;在loader里加上query:{presets:[‘es2015’,’react’]}</p>
<h3 id="2-配置-babelrc文件"><a href="#2-配置-babelrc文件" class="headerlink" title="2.配置.babelrc文件"></a>2.配置.babelrc文件</h3><p>&emsp;&emsp;新建.babelrc文件，按照如下配置即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [&quot;es2015&quot;,&quot;react&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="四、配置完成。开始工程"><a href="#四、配置完成。开始工程" class="headerlink" title="四、配置完成。开始工程"></a>四、配置完成。开始工程</h2><blockquote>
<p>npm install –save react react-dom</p>
</blockquote>
<h3 id="1-安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示："><a href="#1-安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示：" class="headerlink" title="1.安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示："></a>1.安装好react和react-dom开发包，就可以进行开发工作了。我的项目目录如下图所示：</h3><p><img src="../dist/blog/dist/2017/03/18/build-react-babel-webpack-environment/project.png" alt="项目目录"></p>
<h3 id="2-在src下新建main-js文件，其中的代码也很简单，就是用react在页面输出一个hello-world（这貌似是业界接触新技术的必写经典案例，哈哈。）"><a href="#2-在src下新建main-js文件，其中的代码也很简单，就是用react在页面输出一个hello-world（这貌似是业界接触新技术的必写经典案例，哈哈。）" class="headerlink" title="2.在src下新建main.js文件，其中的代码也很简单，就是用react在页面输出一个hello world（这貌似是业界接触新技术的必写经典案例，哈哈。）"></a>2.在src下新建main.js文件，其中的代码也很简单，就是用react在页面输出一个hello world（这貌似是业界接触新技术的必写经典案例，哈哈。）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;</span><br><span class="line">import ReactDOM from  &quot;react-dom&quot;</span><br><span class="line">ReactDOM.render(</span><br><span class="line">    &lt;h1&gt;hello,worlddddd&lt;/h1&gt;,</span><br><span class="line">    document.getElementById(&quot;root&quot;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="3-在项目根目录新建index-html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是-dist-bundle-js，否则页面不能引用到main-js里的内容。"><a href="#3-在项目根目录新建index-html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是-dist-bundle-js，否则页面不能引用到main-js里的内容。" class="headerlink" title="3.在项目根目录新建index.html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是./dist/bundle.js，否则页面不能引用到main.js里的内容。"></a>3.在项目根目录新建index.html，其内容非常简单，仅仅是在body里添加一个id为root的div。然后引入外部js，这里js的路径要注意了，因为我们要导入的是打包好的js文件，所以，script的src值应该是<code>./dist/bundle.js</code>，否则页面不能引用到main.js里的内容。</h3><h3 id="4-执行webpack进行打包"><a href="#4-执行webpack进行打包" class="headerlink" title="4.执行webpack进行打包"></a>4.执行webpack进行打包</h3><h3 id="5-执行webpack-dev-server-–content-base。可以看到hello-world正常显示出来了。此时个性main-js里的内容，页面上会实时更新。"><a href="#5-执行webpack-dev-server-–content-base。可以看到hello-world正常显示出来了。此时个性main-js里的内容，页面上会实时更新。" class="headerlink" title="5.执行webpack-dev-server –content-base。可以看到hello world正常显示出来了。此时个性main.js里的内容，页面上会实时更新。"></a>5.执行webpack-dev-server –content-base。可以看到hello world正常显示出来了。此时个性main.js里的内容，页面上会实时更新。</h3><h2 id="五、写在后面"><a href="#五、写在后面" class="headerlink" title="五、写在后面"></a>五、写在后面</h2><p>&emsp;&emsp;当我执行webpack后，发现在打包的dist目录下，并没有找到我的index.html文件，按道理来说，html文件不是应该随着打包一起进去的吗，否则我在发布的时候没有html怎么行。后来百度才发现，漏掉了最重要的一个东西：<code>HtmlWebpackPlugin</code>。这个插件的作用是依据一个简单的模板，帮你生成最终的Html5文件，这个文件中自动引用了你打包后的JS文件。每次编译都在文件名中插入一个不同的哈希值。也就是说，有了这个配置，在html中根本不需要我们手动引入js文件，打包的时候html会根据配置自动引入。</p>
<h3 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h3><blockquote>
<p>npm install –save-dev html-webpack-plugin</p>
</blockquote>
<h3 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h3><p>&emsp;&emsp;在webpack配置文件中顶部加入：<code>var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)</code>。在plugins里进行如下配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        new HtmlWebpackPlugin(&#123;</span><br><span class="line">            title:&quot;react demo&quot;,</span><br><span class="line">            filename:&quot;index.html&quot;,</span><br><span class="line">            template:&quot;index.html&quot;,</span><br><span class="line">            inject:true</span><br><span class="line">        &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>title</strong>:表示html中title的值<br><strong>filename</strong>:输出的 HTML 文件名，默认是 index.html, 也可以直接配置带有子目录。<br><strong>template</strong>: 模板文件路径，支持加载器，比如 html!./index.html<br><strong>inject</strong>: true | ‘head’ | ‘body’ | false  ,注入所有的资源到特定的 template 或templateContent 中，如果设置为 true 或者 body，所有的 javascript 资源将被放置到 body 元素的底部，’head’ 将放置到 head 元素中。</p>
</blockquote>
<h3 id="3-去掉html中的script引用，执行webpack"><a href="#3-去掉html中的script引用，执行webpack" class="headerlink" title="3.去掉html中的script引用，执行webpack"></a>3.去掉html中的script引用，执行webpack</h3><p>&emsp;&emsp;执行了webpack后，你会发现dist目录下多了个index.html，打开发现在body部分自动引入了bundle.js。</p>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>&emsp;&emsp;本文总结了手动搭建react开发环境的步骤及部分注意点，尽管都是些基本配置，但不得不注意这个过程中多数的坑，只有经历了才知道。可能我的总结不尽完整，后续开发过程中配置肯定会越来越复杂，坑也会有的，先就这些吧。未完待续……</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/01/18/ScopeChain/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/01/18/ScopeChain/" itemprop="url">
                  关于作用域和作用域链
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-18T16:38:10+08:00">
                2017-01-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/01/18/ScopeChain/" class="leancloud_visitors" data-flag-title="关于作用域和作用域链">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;本来是计划写一下JS闭包的概念的。但发现要准确理解闭包的之前，必须要先弄明白几个重要的概念：</p>
<h2 id="一、执行环境"><a href="#一、执行环境" class="headerlink" title="一、执行环境"></a>一、执行环境</h2><hr>
<p>&emsp;&emsp;执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每一个执行环境都有一个与之关联的变量对象，用于保存执行环境中定义的变量和函数。要注意的是，<font color="red">执行环境和变量对象都是在执行函数的时候创建，而并非是在定义函数的时候创建的</font>。<br>&emsp;&emsp;当执行流进入到函数时，该函数的执行环境将被推入到一个环境栈中，等到函数执行完毕，其环境将被弹出并销毁，保存在其中的变量和函数也随之销毁，并把控制权交给之前的执行环境。<font color="red">这个环境栈其实就是作用域链</font>。</p>
<h2 id="二、作用域"><a href="#二、作用域" class="headerlink" title="二、作用域"></a>二、作用域</h2><hr>
<h3 id="1、全局作用域"><a href="#1、全局作用域" class="headerlink" title="1、全局作用域"></a>1、全局作用域</h3><p>&emsp;&emsp;•&ensp;所有在全局环境中定义的变量都拥有全局作用域。<br>&emsp;&emsp;•&ensp;所有未经声明的变量都是全局变量，拥有全局作用域。</p>
<h3 id="2、局部作用域"><a href="#2、局部作用域" class="headerlink" title="2、局部作用域"></a>2、局部作用域</h3><p>&emsp;&emsp;除了以上两种情况，其余的变量都是局部变量，局部变量一般位于函数或对象内部。<br>&emsp;&emsp;注意：尽量不要定义全局变量，因为全局变量可以被所有的函数和对象访问到，很可能引起属性冲突和全局环境污染。尤其是在团队项目当中，如果应用不恰当，很可能造成某个全局属性的值不知道是怎么来的。</p>
<h2 id="三、作用域链"><a href="#三、作用域链" class="headerlink" title="三、作用域链"></a>三、作用域链</h2><hr>
<p>&emsp;&emsp;作用域链保证对执行环境有权访问的所有变量和函数的有序访问。之前也提到过，执行环境组成的环境栈形成一个链式调用，最顶上的环境永远是当前执行流执行到的函数的执行环境。这也就是为什么说作用域链的最前端总是当前执行环境的变量对象。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/01/17/Inherit/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/01/17/Inherit/" itemprop="url">
                  JavaScript继承
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-17T15:59:50+08:00">
                2017-01-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/01/17/Inherit/" class="leancloud_visitors" data-flag-title="JavaScript继承">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;前面总结了JS对象的创建，既然有对象的创建，自然就离不开继承，本篇将总结一下JS几种实现继承的方法：</p>
<h2 id="一、原型链继承"><a href="#一、原型链继承" class="headerlink" title="一、原型链继承"></a>一、原型链继承</h2><hr>
<p>&emsp;&emsp;我们知道每个对象都有一个指定的原型对象，这个原型对象是可以被所有对象的实例访问到的，因此可以采用将子类的原型指针指向要继承的父类的实例。代码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=<span class="string">'tom'</span>;</span><br><span class="line">    <span class="keyword">this</span>.age=<span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sex=<span class="string">'male'</span>;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype=<span class="keyword">new</span> Parent(); <span class="comment">//继承</span></span><br><span class="line">Child.prototype.constructor=Child;</span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child();</span><br><span class="line">child.sayName();</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种继承方式存在两个严重的问题：</p>
<blockquote>
<p>1、由于原型对象中的属性和方法可以被所有的实例共享，因此，假如某个属性值是个引用类型，比如：数组。那么当一个实例当中修改了数组的值，其余实例中的该属性值都会发生变化。这显然是不科学的；<br>2、子类在继承父类的时候，无法动态地给父类构造函数传递参数。因此，这种情况下即使子类继承到了父类的属性也没有意义，因为父类中的属性没办法取到值。你可能会说：我们可以在<code>Child.prototype=new Parent();</code>这一句的时候给父类属性赋值。但请注意，这一句只会执行一次，那就是在为Child重新指定原型对象的时候，而并不会在每次创建实例的时候执行。所以，即使在这一句能设值，那也是在创建实例时不能改变的。</p>
</blockquote>
<h2 id="二、借用构造函数继承"><a href="#二、借用构造函数继承" class="headerlink" title="二、借用构造函数继承"></a>二、借用构造函数继承</h2><hr>
<p>&emsp;&emsp;针对第一种继承方式的问题，第二种继承方式有所改善，构造函数继承方式可以向父类构造函数传递参数了。直接上代码说明：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">    <span class="keyword">this</span>.sayAge=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayName=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>);<span class="comment">// 继承</span></span><br><span class="line">    <span class="keyword">this</span>.sex=<span class="string">'male'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child=<span class="keyword">new</span> Child(<span class="string">'Jerry'</span>,<span class="number">22</span>);</span><br><span class="line">child.sayAge(); <span class="comment">//22</span></span><br><span class="line">child.sayName(); <span class="comment">//Uncaught TypeError: child.sayName is not a function</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;把这段代码复制到控制台运行，结果是，可以弹出22，但运行到sayName()方法的时候，程序找不到sayName方法。尽管构造函数方式也能实现继承，但它的缺点也是显而易见的：</p>
<blockquote>
<p>1、存在于父类中的方法没办法实现共享，这跟创建对象时的构造函数方式有着相同的问题，每创建一个实例也要创建一份同样的方法，造成内存浪费<br>2、刚刚的报错已经提示很明显了，为什么会找不到sayName方法？因为子类实例根本无法访问到父类原型对象的属性和方法！</p>
</blockquote>
<h2 id="三、组合继承"><a href="#三、组合继承" class="headerlink" title="三、组合继承"></a>三、组合继承</h2><hr>
<p>&emsp;&emsp;组合继承，是由原型链继承和借用构造函数继承两种方式结合，取二者之所长形成的一种继承模式，因此叫做组合继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name+<span class="string">'，我的书：'</span>+<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype=<span class="keyword">new</span> Parent(); <span class="comment">//继承公用方法</span></span><br><span class="line">Child.prototype.constructor=Child;</span><br><span class="line"><span class="keyword">var</span> child1=<span class="keyword">new</span> Child(<span class="string">'tom'</span>,<span class="number">25</span>,<span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> child2=<span class="keyword">new</span> Child(<span class="string">'jerry'</span>,<span class="number">20</span>,<span class="string">'female'</span>);</span><br><span class="line">child2.book.push(<span class="string">'book4'</span>);</span><br><span class="line">child1.say(); <span class="comment">//我是tom，我的书：book1,book2,book3</span></span><br><span class="line">child2.say(); <span class="comment">//我是jerry，我的书：book1,book2,book3,book4</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;运行这段代码，你会发现，say方法是放在父类原型对象中的，程序可以正常访问到，而且，不同的实例各自有一份引用类型的实例，一个实例对数组的改变不会影响其他实例。这种模式就要求程序员在创建对象的写法上要规范了，如果我们把公用方法写在父类的构造函数中，无论我们采用哪种继承方式，都会有重复的方法被创建占用内存。<br>&emsp;&emsp;这种继承方式已经解决了之前提出的所有问题，算是继承中用得最多的一种模式。但它也并非最优，<strong>实际上我们调用了两次父类的构造函数：一次是在为子类创建原型对象的时候，另一次是在执行子类构造函数的时候也会调用父类的构造函数</strong>。</p>
<h2 id="四、寄生组合式继承"><a href="#四、寄生组合式继承" class="headerlink" title="四、寄生组合式继承"></a>四、寄生组合式继承</h2><hr>
<p>&emsp;&emsp;其实，仔细想想，我们执行<code>Child.prototype=new Parent();</code>这一句，无非就是想让子类的原型指针指向父类的原型对象嘛，那我们没必要创建父类的实例，我们只需要有一份父类原型对象的拷贝不就行了？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">    F.prototype=o;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name=name;</span><br><span class="line">    <span class="keyword">this</span>.age=age;</span><br><span class="line">    <span class="keyword">this</span>.book=[<span class="string">'book1'</span>,<span class="string">'book2'</span>,<span class="string">'book3'</span>];</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'我是'</span>+<span class="keyword">this</span>.name+<span class="string">'，我的书：'</span>+<span class="keyword">this</span>.book);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name,age,sex</span>)</span>&#123;</span><br><span class="line">    Parent.apply(<span class="keyword">this</span>,<span class="built_in">arguments</span>); <span class="comment">//继承属性</span></span><br><span class="line">    <span class="keyword">this</span>.sex=sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> prototype=object(Parent.prototype); <span class="comment">//这里的prototype就是子类需要继承的原型对象**</span></span><br><span class="line">prototype.constructor=Child; <span class="comment">//把原型对象的constructor属性重新指向构造函数</span></span><br><span class="line">Child.prototype=prototype; <span class="comment">//将原型指针指向新的原型对象</span></span><br><span class="line"><span class="keyword">var</span> child1=<span class="keyword">new</span> Child(<span class="string">'tom'</span>,<span class="number">25</span>,<span class="string">'male'</span>);</span><br><span class="line"><span class="keyword">var</span> child2=<span class="keyword">new</span> Child(<span class="string">'jerry'</span>,<span class="number">20</span>,<span class="string">'female'</span>);</span><br><span class="line">child2.book.push(<span class="string">'book4'</span>);</span><br><span class="line">child1.say(); <span class="comment">//我是tom，我的书：book1,book2,book3</span></span><br><span class="line">child2.say(); <span class="comment">//我是jerry，我的书：book1,book2,book3,book4</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;这种方式单独定义了一个object方法，这个方法返回一个空对象的实例，这个实例的原型指针指向Parent的原型对象。所以，我们只需要将子类的原型指针指向object方法返回的这个对象，就可以继承到父类的原型对象的方法和属性了。<br>&emsp;&emsp;这种方法避免了两次调用父类构造函数，用一个不包含任何自定义属性的对象来替代之前创建父类实例进行原型继承的方式。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://ouyangdecai.com/blog/blog/2017/01/16/SessionAndCookie/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Tomee Ouyang">
    <meta itemprop="description" content>
    <meta itemprop="image" content="/blog/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="欧阳德才">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="欧阳德才" src>
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/blog/2017/01/16/SessionAndCookie/" itemprop="url">
                  Session和Cookie：相爱相杀
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-01-16T15:57:34+08:00">
                2017-01-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/blog/categories/技术/" itemprop="url" rel="index">
                    <span itemprop="name">技术</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          

          
          
             <span id="/blog/2017/01/16/SessionAndCookie/" class="leancloud_visitors" data-flag-title="Session和Cookie：相爱相杀">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>&emsp;&emsp;关于session和cookie，以前在大学就开始接触，但从来没有对这两个东西有一个系统的认识。如今想来，是时候对它们进行一下梳理了。</p>
<h2 id="一、认识cookie"><a href="#一、认识cookie" class="headerlink" title="一、认识cookie"></a>一、认识cookie</h2><p>&emsp;&emsp;cookie是存在于客户端的状态跟踪机制。由于HTTP是无状态协议，当客户端向服务器发送请求，服务器对请求进行响应，随后连接断开，当下一次同一个客户端再次访问服务器的时候，服务器并不知道这个请求就是上一次的发起者，所有的请求数据都要重新构造一遍，服务端的效率相当低下。<br>&emsp;&emsp;所以，cookie就发挥了作用。客户端浏览器每一次向服务器发送请求的时候，都要在http请求头中携带关于cookie的信息随之发送到服务器，服务器获得cookie的信息并根据信息判断此次请求的发送者是不是之前发送过请求的“人”，以此判断做出相应的反应。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> getCookie(Cookies[] cookies,String name)&#123;</span><br><span class="line">    <span class="keyword">if</span>(cookies != null)&#123;</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cookie.getName() == name)&#123;</span><br><span class="line">                <span class="built_in">return</span> cookie.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cookies[] cookies=request.getCookies();</span><br><span class="line">String account=getCookie(cookies,<span class="string">"account"</span>) ;</span><br><span class="line">String password=getCookie(cookies,<span class="string">"password"</span>);</span><br><span class="line"><span class="keyword">if</span>(account==null)&#123;</span><br><span class="line">    response.addCookie(new Cookie(<span class="string">"account"</span>,<span class="string">"ouyang"</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(password == null)&#123;</span><br><span class="line">    response.addCookie(new Cookie(<span class="string">"password"</span>,<span class="string">"123456"</span>))</span><br><span class="line">&#125;</span><br><span class="line">response.setHeader(<span class="string">"Set-Cookie"</span>);</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;打个比方，我第一次去某城市乘地铁，由于没有当地的交通卡，每次乘地铁都必须要手动买票，相当不方便，于是地铁管理处给我办了张交通卡，以后每次乘地铁刷一下卡就可以直接进站了。<br>&emsp;&emsp;cookie也相当于服务器给每个访问它的客户端办了一个通行卡。就拿登录来说，我第一次登录的时候服务端检测到我的cookie是空的，那么它就把我当前登录的用户名和密码设置到cookie中并写入返回的http响应头中，客户端接收到cookie内容后将其保存在客户端，下一次请求的时候http请求头中自然就携带了已经验证过的用户名和密码，在服务器可以直接登录了。<br>&emsp;&emsp;cookie包含名称、值、过期时间、域、路径这几个重要的内容。下面简单介绍一下：</p>
<blockquote>
<p><strong>名称（name）</strong>：cookie名称，<br><strong>值（value）</strong>：名称对应的cookie值，<br><strong>过期时间（Expires)</strong>：若不设置过期时间，则表示cookie的过期时间为浏览器会话时间，一旦浏览器关闭，cookie就会消失。如果设置了过期时间，cookie将会被储存到本地硬盘中，在设置的这个时间到来之前，无论浏览器是否关闭，cookie都会存在。当设置为负数时，表示cookie在浏览器关闭时立即消失，设置为0时表示删除该cookie。<br><strong>域名（Domain)</strong>：限制可以访问该cookie的域名，设置的时候别忘了要包含最前面的点（“.”）如cookie.setDomain(“.baidu.com”)，<br><strong>路径（Path)</strong>：限制哪些路径下的文件可以访问到该cookie，<br><strong>是否使用安全协议传输（secure)</strong>：布尔值。如果为true，表示是否只在SSH连接时传递该cookie</p>
</blockquote>
<p>&emsp;&emsp;cookie具有不可跨域名性。同时，cookie也是不安全的，别人可以分析存放在本地的cookie并进行cookie欺骗。cookie的大小不能超过4K，因为过大的cookie在浏览器和服务器之间交互相当耗带宽，影响性能。对于这种只能存储基本小容量信息的cookie，远远不能满足更广泛的信息存储需求，于是，session登场了。</p>
<h2 id="二、认识session"><a href="#二、认识session" class="headerlink" title="二、认识session"></a>二、认识session</h2><p>&emsp;&emsp;session是服务端存储客户信息的机制。它以一种散列表的结构存储信息。尽管session打破了cookie容量的限制，但是，它也需要一种将客户端与服务端对应起来的机制，否则，服务器无法知道哪个session是属于当前登录用户的。这就形成了cookie与session合作共赢的格局。<br>&emsp;&emsp;当浏览器向服务器发起请求时，服务器首先去检查http请求头的cookie中是否包含一个sessionid，如果有，就根据sessionid找到对应的session，读取其中的信息。如果没有，就为当前请求客户创建一个session，并把唯一标识的sessionid存入cookie返回给服务器。等到下次再请求的时候，请求信息中就自然携带了对应的sessionid，并在服务器找到对应的session信息。<br>&emsp;&emsp;由于cookie可以在客户端被禁止，所以，此时要想sessionid传到服务器，就需要启用URL地址重写，sessionid以字符串的形式追回到url末尾，服务器会解析出sessionid，效果跟cookie携带是一样的。</p>
<p>&emsp;&emsp;更多关于session和cookie的信息在<a href="http://blog.csdn.net/fangaoxin/article/details/6952954/" target="_blank" rel="noopener">这里</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/blog/images/avatar.gif" alt="Tomee Ouyang">
          <p class="site-author-name" itemprop="name">Tomee Ouyang</p>
          <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
        
          
            <div class="site-state-item site-state-posts">
              <a href="/blog/archives">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories">
              <a href="/blog/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/blog/tags">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fonture" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/2088048923/profile?topnav=1&wvr=6&is_all=1" target="_blank" title="微博">
                  
                    <i class="fa fa-fw fa-weibo"></i>
                  
                  微博
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/ou-yang-de-cai" target="_blank" title="知乎">
                  
                    <i class="fa fa-fw fa-angellist"></i>
                  
                  知乎
                </a>
              </span>
            
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              友情链接
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://macshuo.com/" title="MacTalk" target="_blank">MacTalk</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="https://yuguo.us/" title="Yuguo" target="_blank">Yuguo</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://cnedwan.com/" title="Xuheng" target="_blank">Xuheng</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tomee Ouyang</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/blog/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/blog/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/blog/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/blog/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/blog/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/blog/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/blog/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  
      
  

  




  
  

  

  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("xUAzEcVj0ETQXIxIKTDo7aHM-gzGzoHsz", "sVrjzN8U2N1AhxFwcjLd8Cs9");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  


</body>
</html>
